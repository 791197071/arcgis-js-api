// COPYRIGHT Â© 2018 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.12/esri/copyright.txt for details.

define(["require","exports"],function(e,n){return{edgeRenderer:{"adjustProjectedPosition.glsl":"uniform vec2 uDepthBias;\nuniform vec2 uViewportDimInv;\nbool isNaN(float val) {\n  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;\n}\nvec2 calculateProjectedBiasXY(vec4 projPos, vec3 worldNormal) {\n  float offsetXY = uDepthBias.x;\n  float offsetZ  = uDepthBias.y;\n  vec4 projNormal = uProj * uView * vec4(worldNormal, 0.0);\n  return offsetXY * projPos.w * 2.0 * uViewportDimInv * normalize(projNormal.xyz).xy;\n}\nfloat calculateProjectedBiasZ(vec4 projPos) {\n  float offsetZ = uDepthBias.y;\n  return sqrt(projPos.z) * offsetZ;\n}\nvec4 adjustProjectedPosition(vec4 projPos, vec3 worldNormal, float lineWidth) {\n  vec2 offsetXY = calculateProjectedBiasXY(projPos, worldNormal);\n  if (!isNaN(offsetXY.x) && !isNaN(offsetXY.y)) {\n    projPos.xy += offsetXY;\n  }\n  projPos.z += calculateProjectedBiasZ(projPos);\n  return projPos;\n}","edgeRenderer.frag":"#include <util/fsPrecision.glsl>\n#include <util/slice.glsl>\nvarying vec4 vColor;\nvarying float vRadius;\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying float vLineLengthPixels;\nvarying float vSizeFalloffFactor;\nvarying float vLineIndex;\n#define COVERAGE_TEST_THRESHOLD 0.01\n#include <edgeRenderer/lineOffset.glsl>\nvec2 lineWithCapsDistance(float radius, vec2 position, float lineLength) {\n  float lineOffset = calculateLineOffset();\n  float positionX = position.x - lineOffset;\n  if (radius < 1.0) {\n    float coverageX = clamp(min(radius, positionX + 0.5) - max(-radius, positionX - 0.5), 0.0, 1.0);\n    float coverageY = clamp(min(lineLength, position.y + 0.5) - max(0.0, position.y - 0.5), 0.0, 1.0);\n    float coverage = min(coverageX, coverageY);\n    return vec2(0.5 - coverage, 0.0);\n  }\n  else {\n    float positionOnCap = position.y - clamp(position.y, 0.0, lineLength);\n    vec2 lineToPosition = vec2(positionX, positionOnCap);\n    return vec2(length(lineToPosition) - radius, positionOnCap / radius);\n  }\n}\nvoid main() {\n  float radius = vRadius * calculateLinePressure();\n  vec2 distance = lineWithCapsDistance(radius, vPosition.xy, vLineLengthPixels);\n  float coverage = clamp(0.5 - distance.x, 0.0, 1.0);\n#ifdef ANTIALIASING\n  const float coverageLimit = COVERAGE_TEST_THRESHOLD;\n#else\n  float coverageLimit = radius <= 0.5 ? COVERAGE_TEST_THRESHOLD : 0.75;\n#endif\n  if (coverage < coverageLimit) {\n    discard;\n  }\n  discardBySlice(vWorldPosition);\n  float alpha = vColor.a * coverage;\n  gl_FragColor = vec4(vColor.rgb, alpha);\n}","edgeRenderer.vert":"#include <util/vsPrecision.glsl>\nuniform mat4 uProj;\nuniform mat4 uView;\nuniform mat4 uModel;\nuniform vec3 uCameraPosition;\nuniform vec2 uPixelToNDC;\nuniform vec2 uNDCToPixel;\nuniform float uPixelRatio;\nattribute vec3 aPosition0;\nattribute vec3 aPosition1;\nattribute float aVariantOffset;\nattribute float aVariantStroke;\nattribute float aVariantExtension;\n#ifdef SILHOUETTE\nattribute vec3 aNormalA;\nattribute vec3 aNormalB;\n#else\nattribute vec3 aNormal;\n#endif\nattribute vec2 aSideness;\nattribute vec2 aPackedAttributes;\nstruct UnpackedAttributes {\nvec2 sideness;\nvec2 sidenessNorm;\nfloat lineWidthPixels;\nfloat extensionLengthPixels;\n#if (MODE == MODE_UBER)\nfloat type;\n#endif\n};\nvarying vec4 vColor;\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying float vRadius;\nvarying float vLineLengthPixels;\nvarying float vSizeFalloffFactor;\n#include <edgeRenderer/adjustProjectedPosition.glsl>\n#include <edgeRenderer/styleOutputs.glsl>\n#include <edgeRenderer/lineAmplitude.glsl>\n#include <edgeRenderer/util.glsl>\nvec4 calculateGeometricOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\n  vec2 sideness = unpackedAttributes.sideness;\n  vec2 sidenessNorm = unpackedAttributes.sidenessNorm;\n  vWorldPosition = mix(worldPosV0, worldPosV1, sidenessNorm.y).xyz;\n  vec4 viewPos = mix(viewPosV0, viewPosV1, sidenessNorm.y);\n  vec4 projPosV0 = uProj * viewPosV0;\n  vec4 projPosV1 = uProj * viewPosV1;\n  vec4 projPos = uProj * viewPos;\n  vec3 screenSpaceLineNDC = (projPosV1.xyz / projPosV1.w - projPosV0.xyz / projPosV0.w);\n  vec2 screenSpaceLinePixels = screenSpaceLineNDC.xy * uNDCToPixel;\n  float lineLengthPixels = length(screenSpaceLinePixels);\n  float dzPerPixel = screenSpaceLineNDC.z / lineLengthPixels;\n  vec2 screenSpaceDirection = screenSpaceLinePixels / lineLengthPixels;\n  vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x) * sideness.x;\n  float falloffFactor = distanceBasedPerspectiveFactor(-viewPos.z) * uPixelRatio;\n  float lineWidthPixels = unpackedAttributes.lineWidthPixels * falloffFactor;\n  float extensionLengthPixels = calculateExtensionLength(unpackedAttributes.extensionLengthPixels, lineLengthPixels) * falloffFactor;\n  float lineAmplitudePixels = calculateLineAmplitude(unpackedAttributes) * uPixelRatio;\n  vSizeFalloffFactor = falloffFactor;\n  float lineWidthAndAmplitudePixels = lineWidthPixels + lineAmplitudePixels + lineAmplitudePixels;\n  float extendedLineLengthPixels = lineLengthPixels + extensionLengthPixels + extensionLengthPixels;\n#ifdef ANTIALIASING\n  const float aaPaddingPixels = 1.0;\n  float halfAAPaddedLineWidthAndAmplitudePixels = lineWidthAndAmplitudePixels * 0.5 + aaPaddingPixels;\n  float aaPaddedRoundedCapSizePixels = lineWidthPixels * 0.5 + aaPaddingPixels;\n  float aaPaddedLineLengthPixels = extendedLineLengthPixels + aaPaddingPixels + aaPaddingPixels;\n  float halfAAPaddedLineLengthPixels = aaPaddedLineLengthPixels * 0.5;\n#else\n  float halfAAPaddedLineWidthAndAmplitudePixels = max(lineWidthAndAmplitudePixels, 1.0) * 0.5;\n  float aaPaddedRoundedCapSizePixels = max(lineWidthPixels, 1.0) * 0.5;\n  float halfAAPaddedLineLengthPixels = max(extendedLineLengthPixels, 1.0) * 0.5;\n#endif\n  vec2 halfAAPaddedLineWidthAndAmplitudeNDC = halfAAPaddedLineWidthAndAmplitudePixels * uPixelToNDC;\n  vec2 aaPaddedRoundedCapSizeNDC = aaPaddedRoundedCapSizePixels * uPixelToNDC;\n  vec2 extensionLengthNDC = extensionLengthPixels * uPixelToNDC;\n  vec2 ndcOffset = (\n      screenSpaceDirection * sideness.y * (aaPaddedRoundedCapSizeNDC + extensionLengthNDC)\n    + perpendicularScreenSpaceDirection * halfAAPaddedLineWidthAndAmplitudeNDC\n  );\n  projPos.xy += ndcOffset * projPos.w;\n  projPos.z += (dzPerPixel * (aaPaddedRoundedCapSizePixels + extensionLengthPixels)) * sideness.y * projPos.w;\n  projPos = adjustProjectedPosition(projPos, worldNormal, 1.0 + max((lineWidthAndAmplitudePixels - 1.0) * 0.5, 0.0));\n  float aaPaddedLineWithCapsLengthPixels = extendedLineLengthPixels + aaPaddedRoundedCapSizePixels + aaPaddedRoundedCapSizePixels;\n  float pixelPositionAlongLine = aaPaddedLineWithCapsLengthPixels * sidenessNorm.y - aaPaddedRoundedCapSizePixels;\n  vPosition = vec3(\n    halfAAPaddedLineWidthAndAmplitudePixels * sideness.x,\n    pixelPositionAlongLine,\n    pixelPositionAlongLine / extendedLineLengthPixels\n  );\n  vRadius = lineWidthPixels * 0.5;\n  vLineLengthPixels = extendedLineLengthPixels;\n#ifdef SILHOUETTE\n  gl_Position = isSilhouetteEdge(viewPosV0, aNormalA, aNormalB) ? projPos : vec4(10.0, 10.0, 10.0, 1.0);\n#else\n  gl_Position = projPos;\n#endif\n#if (MODE == MODE_UBER)\n  if (unpackedAttributes.type <= 0.0 && lineLengthPixels <= 3.0) {\n    gl_Position = vec4(10.0, 10.0, 10.0, 1.0);\n  }\n#elif (MODE == MODE_SKETCH)\n  if (lineLengthPixels <= 3.0) {\n    gl_Position = vec4(10.0, 10.0, 10.0, 1.0);\n  }\n#endif\n  return projPos;\n}\n#if (MODE == MODE_UBER)\nUnpackedAttributes unpackAttributes(ComponentData component) {\n  vec2 sidenessNorm = aSideness;\n  vec2 sideness = sidenessNorm * 2.0 - 1.0;\n  float fType = component.type;\n  float extensionLengthPixels = component.extensionLength;\n  float lineWidth = component.lineWidth;\n  if (fType <= 0.0) {\n    extensionLengthPixels *= aVariantExtension * 2.0 - 1.0;\n  }\n  return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels, fType);\n}\n#else\nUnpackedAttributes unpackAttributes(ComponentData component) {\n  vec2 sidenessNorm = aSideness;\n  vec2 sideness = sidenessNorm * 2.0 - 1.0;\n  float extensionLengthPixels = component.extensionLength;\n#if (MODE == MODE_SKETCH)\n  extensionLengthPixels *= aVariantExtension * 2.0 - 1.0;\n#endif\n  float lineWidth = component.lineWidth;\n  return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels);\n}\n#endif\nvoid main() {\n  ComponentData component = readComponentData();\n  UnpackedAttributes unpackedAttributes = unpackAttributes(component);\n  vec4 worldPosV0 = uModel * vec4(aPosition0, 1.0);\n  vec4 worldPosV1 = uModel * vec4(aPosition1, 1.0);\n  vec4 viewPosV0 = uView * worldPosV0;\n  vec4 viewPosV1 = uView * worldPosV1;\n#ifdef SILHOUETTE\n  vec3 worldNormal = silhouetteWorldNormal(aNormalA, aNormalB);\n#else\n  vec3 worldNormal = modelToWorldNormal(aNormal);\n#endif\n  vec4 projPos = calculateGeometricOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, worldNormal, unpackedAttributes);\n  vColor = component.color;\n  calculateStyleOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, projPos, worldNormal, unpackedAttributes);\n}","lineAmplitude.glsl":"#if (MODE == MODE_UBER || MODE == MODE_SOLID)\n  float calculateLineAmplitudeSolid() {\n    return 0.0;\n  }\n#endif\n#if (MODE == MODE_SOLID)\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\n    return calculateLineAmplitudeSolid();\n  }\n#endif\n#if (MODE == MODE_UBER || MODE == MODE_SKETCH)\n  uniform float uStrokesAmplitude;\n  float calculateLineAmplitudeSketch() {\n    return uStrokesAmplitude;\n  }\n#endif\n#if (MODE == MODE_SKETCH)\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\n    return calculateLineAmplitudeSketch();\n  }\n#endif\n#if (MODE == MODE_UBER)\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\n    float type = unpackedAttributes.type;\n    if (type <= 0.0) {\n      return calculateLineAmplitudeSketch();\n    }\n    else {\n      return calculateLineAmplitudeSolid();\n    }\n  }\n#endif","lineOffset.glsl":"#include <util/encoding.glsl>\n#if (MODE == MODE_UBER || MODE == MODE_SKETCH)\n  uniform sampler2D uStrokesTexture;\n  uniform float uStrokesNormalizationScale;\n  varying vec2 vStrokeUV;\n  float calculateLineOffsetSketch() {\n    float offsetNorm = rgba2float(texture2D(uStrokesTexture, vStrokeUV));\n    return (offsetNorm - 0.5) * uStrokesNormalizationScale;\n  }\n  float calculateLinePressureSketch() {\n    return rgba2float(texture2D(uStrokesTexture, vStrokeUV + vec2(0.0, 0.5)));\n  }\n#endif\n#if (MODE == MODE_SKETCH)\n  float calculateLineOffset() {\n    return calculateLineOffsetSketch();\n  }\n  float calculateLinePressure() {\n    return calculateLinePressureSketch();\n  }\n#endif\n#if (MODE == MODE_UBER || MODE == MODE_SOLID)\n  float calculateLineOffsetSolid() {\n    return 0.0;\n  }\n  float calculateLinePressureSolid() {\n    return 1.0;\n  }\n#endif\n#if (MODE == MODE_SOLID)\n  float calculateLineOffset() {\n    return calculateLineOffsetSolid();\n  }\n  float calculateLinePressure() {\n    return calculateLinePressureSolid();\n  }\n#endif\n#if (MODE == MODE_UBER)\n  varying float vType;\n  float calculateLineOffset() {\n    if (vType <= 0.0) {\n      return calculateLineOffsetSketch();\n    }\n    else {\n      return calculateLineOffsetSolid();\n    }\n  }\n  float calculateLinePressure() {\n    if (vType <= 0.0) {\n      return calculateLinePressureSketch();\n    }\n    else {\n      return calculateLinePressureSolid();\n    }\n  }\n#endif","styleOutputs.glsl":"#if (MODE == MODE_UBER || MODE == MODE_SKETCH)\n  uniform vec2 uStrokesTextureScale;\n  uniform float uStrokesLog2Resolution;\n  uniform float uStrokeVariants;\n  varying vec2 vStrokeUV;\n  varying float vLineIndex;\n  void calculateStyleOutputsSketch(float lineLength, UnpackedAttributes unpackedAttributes) {\n    vec2 sidenessNorm = unpackedAttributes.sidenessNorm;\n    float lineIndex = clamp(ceil(log2(lineLength)), 0.0, uStrokesLog2Resolution);\n    vStrokeUV = vec2(exp2(lineIndex) * sidenessNorm.y, lineIndex * uStrokeVariants + aVariantStroke + 0.5) * uStrokesTextureScale;\n    vStrokeUV.x += aVariantOffset;\n    vLineIndex = lineIndex;\n  }\n#endif\n#if (MODE == MODE_SOLID)\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\n  }\n#elif (MODE == MODE_SKETCH)\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\n    calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);\n  }\n#elif (MODE == MODE_UBER)\n  varying float vType;\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\n    vType = unpackedAttributes.type;\n    if (unpackedAttributes.type <= 0.0) {\n      calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);\n    }\n  }\n#endif","util.glsl":"uniform float uDistanceFalloffFactor;\nfloat distanceBasedPerspectiveFactor(float distance) {\n  return clamp(sqrt(uDistanceFalloffFactor / distance), 0.0, 1.0);\n}\nuniform sampler2D uComponentDataTex;\nuniform vec2 uComponentDataTexInvDim;\nattribute float aComponentIndex;\n#define COMPONENT_COLOR_FIELD_OFFSET 0.0\n#define COMPONENT_OTHER_FIELDS_OFFSET 1.0\n#define COMPONENT_FIELD_COUNT 2.0\n#define LINE_WIDTH_FRACTION_FACTOR 8.0\n#define EXTENSION_LENGTH_OFFSET 128.0\n#define COMPONENT_TEX_WIDTH 4096.0\nvec2 componentTextureCoords(float componentIndex, float fieldOffset) {\n  float fieldIndex = COMPONENT_FIELD_COUNT * componentIndex + fieldOffset;\n  float rowIndex = floor(fieldIndex / COMPONENT_TEX_WIDTH);\n  float colIndex = mod(fieldIndex, COMPONENT_TEX_WIDTH);\n  vec2 linearIndex = vec2(\n    (colIndex + 0.5) / COMPONENT_TEX_WIDTH,\n    (rowIndex + 0.5) * uComponentDataTexInvDim.y\n  );\n  return linearIndex;\n}\nstruct ComponentData {\n  vec4 color;\n  float lineWidth;\n  float extensionLength;\n  float type;\n};\nComponentData readComponentData() {\n  vec2 colorIndex = componentTextureCoords(aComponentIndex, COMPONENT_COLOR_FIELD_OFFSET);\n  vec2 otherIndex = componentTextureCoords(aComponentIndex, COMPONENT_OTHER_FIELDS_OFFSET);\n  vec4 colorValue = texture2D(uComponentDataTex, colorIndex);\n  vec4 otherValue = texture2D(uComponentDataTex, otherIndex);\n  return ComponentData(\n    vec4(colorValue.rgb, colorValue.a * otherValue.w),\n    otherValue.x * (255.0 / LINE_WIDTH_FRACTION_FACTOR),\n    otherValue.y * 255.0 - EXTENSION_LENGTH_OFFSET,\n    -(otherValue.z * 255.0) + 0.5\n  );\n}\nvec3 modelToWorldNormal(vec3 normal) {\n  return (uModel * vec4(normal, 0.0)).xyz;\n}\nvec3 silhouetteWorldNormal(vec3 normalA, vec3 normalB) {\n  return modelToWorldNormal(normalize(normalA + normalB));\n}\nfloat calculateExtensionLength(float extensionLength, float lineLength) {\n  return extensionLength / (log2(max(1.0, 256.0 / lineLength)) * 0.2 + 1.0);\n}\n#ifdef SILHOUETTE\nbool isSilhouetteEdge(vec4 viewPos, vec3 normalA, vec3 normalB) {\n  vec3 viewNormalA = (uView * uModel * vec4(normalA, 0.0)).xyz;\n  vec3 viewNormalB = (uView * uModel * vec4(normalB, 0.0)).xyz;\n  vec3 viewDir = -viewPos.xyz;\n  float faceAVisible = dot(viewDir, viewNormalA);\n  float faceBVisible = dot(viewDir, viewNormalB);\n  return faceAVisible * faceBVisible < 0.0;\n}\n#endif"},environment:{"realisticAtmosphere.frag":"#include <util/fsPrecision.glsl>\n#include <util/encoding.glsl>\n#include <util/color.glsl>\nuniform vec3 v3LightDir;\nuniform vec3 v3InvWavelength;\nuniform vec3 v3InvWavelengthScaled;\nconst float fKrESun = 0.075;\nconst float fKmESun = 0.015;\nuniform vec4 v4Radii;\n#define fInnerRadius v4Radii[0]\n#define fInnerRadius2 v4Radii[1]\n#define fOuterRadius v4Radii[2]\n#define fOuterRadius2 v4Radii[3]\nuniform vec4 v4AtmosParams1;\nuniform vec4 v4AtmosParams2;\n#define fScale v4AtmosParams1.x\n#define v2ScaleDepth vec2(v4AtmosParams1.y,v4AtmosParams2.y)\n#define v2ScaleOverScaleDepth vec2(v4AtmosParams1.z,v4AtmosParams2.z)\n#define v2OneOverScaleDepth vec2(v4AtmosParams1.w,v4AtmosParams2.w)\n#ifndef HAZE\nuniform vec4 v4AtmosParams3;\nuniform float fInnerFadeDistance;\nuniform float fAltitudeFade;\n#define fg v4AtmosParams2.x\n#define fg2 v4AtmosParams3.x\n#define fMiePhaseCoefficients v4AtmosParams3.y\n#define fLowerAlphaBlendBound v4AtmosParams3.z\n#define fOneOverOuterRadiusMinusAlphaBlendBound v4AtmosParams3.w\n#endif\nuniform vec3 v3CameraPos;\nuniform vec2 nearFar;\nuniform vec4 v4SphereComp;\n#define fCameraHeight v4SphereComp[0]\n#define fCameraHeight2 v4SphereComp[1]\n#define fC v4SphereComp[2]\n#define fCSur v4SphereComp[3]\n#ifdef HAZE\nconst float fExposure = 1.5;\n#else\nconst float fExposure = 2.0;\n#endif\n#ifdef HAZE\nuniform sampler2D tDepth;\n#endif\nuniform float showTest;\nvarying vec3 v3EyeDir;\nvarying vec3 v3WorldRay;\nvarying vec2 vtc;\nconst float fSamples = 5.0;\nconst int maxSamples = 5;\n#ifdef HAZE\n  const float fOneOverGamma = 1.0;\n#else\n  const float fOneOverGamma = 0.454545;\n#endif\nconst vec3 v3OneOverGamma = vec3(fOneOverGamma);\nvec3 expTM(vec3 inputColor,float exposure){\n    return pow(1.0 - exp(inputColor * -exposure), v3OneOverGamma);\n}\n#ifndef HAZE\nvec3 reinhardTM(vec3 inputColor, float exposure){\n  vec3 intermediate = inputColor *exposure;\n  intermediate /= (1.0+intermediate);\n  return pow(intermediate, v3OneOverGamma);\n}\n#endif\nfloat scale(float fCos){\n  float x = 1.0 - fCos;\n  return exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\nvoid main() {\n  vec3 cameraPosition = v3CameraPos;\n  vec3 test = vec3(0.0,0.0,0.0);\n  vec3 worldSpaceRay = normalize(v3WorldRay);\n  float B = 2.0 * dot(cameraPosition, worldSpaceRay);\n  float det = B*B - 4.0 * fC;\n  float detSur = B*B - 4.0 * fCSur;\n  float fMinRayStart = 0.0;\n#ifndef HAZE\n  float fSurfaceBlend = 0.0;\n  vec4 surfaceColor = vec4(0.0);\n  if (detSur >= 0.0) {\n    float nearSurfaceT = max(0.0, 0.5 *(-B - sqrt(detSur)));\n    float farSurfaceT = max(0.0, 0.5 *(-B + sqrt(detSur)));\n    if (nearSurfaceT == 0.0) {\n      fMinRayStart = farSurfaceT;\n    }\n    vec3 vPos = cameraPosition + worldSpaceRay * nearSurfaceT;\n    float fLightAngle = dot(v3LightDir, normalize(vPos));\n    float fBrightness = max(0.0, (smoothstep(-1.0, 0.8, 2.0 * fLightAngle)));\n    surfaceColor = vec4(fBrightness, fBrightness, fBrightness, 1.0 - fAltitudeFade);\n    float fRelDist = (farSurfaceT - nearSurfaceT) / fInnerFadeDistance;\n    if (fRelDist > 1.0) {\n      gl_FragColor = surfaceColor;\n      return;\n    }\n    fSurfaceBlend = smoothstep(0.0, 1.0, fRelDist * fRelDist);\n  }\n#endif\n  if (det >= 0.0) {\n#ifdef HAZE\n    float depthSample = texture2D(tDepth, vtc).r;\n    float zNear = nearFar[0];\n    float zFar = nearFar[1];\n    float zNorm = 2.0 * depthSample - 1.0;\n    float linDepth = 2.0 * zNear * zFar /\n      (zFar + zNear - zNorm * (zFar - zNear));\n    float rayEndT;\n    float altitudeAlpha = 1.0;\n    if (depthSample < 1.0 && depthSample > 0.0) {\n      vec3 cameraSpaceRay = normalize(v3EyeDir);\n      cameraSpaceRay /= cameraSpaceRay.z;\n      cameraSpaceRay *= linDepth;\n      float cameraSpaceRayLength = length(cameraSpaceRay);\n      vec3 v3World = cameraPosition + worldSpaceRay * cameraSpaceRayLength;\n      float v3WorldRadius2 = dot(v3World, v3World);\n      float transitionStart = fInnerRadius + 20000.0;\n      float transitionHeight = 25000.0;\n      float transitionEnd = transitionStart + transitionHeight;\n      float edge0 = transitionStart * transitionStart;\n      float edge1 = transitionEnd * transitionEnd;\n      altitudeAlpha = 1.0 - clamp((v3WorldRadius2 - edge0) / (edge1 - edge0), 0.0, 1.0);\n      rayEndT = cameraSpaceRayLength;\n      if (altitudeAlpha > 0.0 && detSur > 0.0) {\n        float nearSurfaceT = 0.5 *(-B - sqrt(detSur));\n        float interp = clamp(((fCameraHeight - fInnerRadius) - 2000000.0) / 6000000.0, 0.0, 1.0);\n        rayEndT = mix(cameraSpaceRayLength, nearSurfaceT, interp);\n      }\n    }\n#endif\n    float rayStartT = 0.5 *(-B - sqrt(det));\n#ifdef HAZE\n    float nearT = abs(rayStartT);\n    float farT = abs(rayEndT);\n#else\n    float rayEndT = 0.5 *(-B + sqrt(det));\n#endif\n    float fDistance;\n    if (rayStartT < fMinRayStart)\n    {\n      rayStartT = fMinRayStart;\n#ifndef HAZE\n      fDistance = fScale * min(0.0, fInnerRadius - fCameraHeight);\n#endif\n    }\n#ifndef HAZE\n    else\n    {\n      fDistance = -1.0;\n    }\n#endif\n    vec3 v3Start = cameraPosition + worldSpaceRay * rayStartT;\n#ifdef HAZE\n    vec3 v3End = cameraPosition + worldSpaceRay * rayEndT;\n    float fEndLength = length(v3End);\n    float fAltitudeEnd = fEndLength - fInnerRadius;\n    float fAltitudeStart = length(v3Start) - fInnerRadius;\n    if (fAltitudeStart < 0.0) {\n      fAltitudeStart = -fAltitudeStart;\n      fAltitudeEnd = -fAltitudeEnd;\n    }\n    float fLightAngle = dot(v3LightDir, v3End) / fEndLength;\n    if (nearT > farT)\n    {\n      if (fAltitudeStart < fAltitudeEnd)\n      {\n        v3End = cameraPosition + worldSpaceRay * rayStartT;\n        v3Start = cameraPosition + worldSpaceRay * rayEndT;\n        worldSpaceRay *= -1.0;\n        float fTmp = fAltitudeStart;\n        fAltitudeStart = fAltitudeEnd;\n        fAltitudeEnd = fTmp;\n      }\n      else if (fAltitudeStart == fAltitudeEnd)\n      {\n        fAltitudeStart += 1.0;\n      }\n    }\n    float fCameraDepth;\n    float fCameraDepthBlue;\n    if (fAltitudeStart > fOuterRadius - fInnerRadius)\n    {\n      fDistance = fInnerRadius - fOuterRadius;\n    } else\n    {\n      fDistance = fAltitudeEnd - fAltitudeStart;\n    }\n#endif\n    vec2 v2OpticalStartDepth = exp(fDistance * v2OneOverScaleDepth);\n    float fRayLength = rayEndT - rayStartT;\n    float fSampleLength = fRayLength / fSamples;\n    float fScaledLength = fSampleLength * fScale;\n    vec3 v3SampleRay = worldSpaceRay * fSampleLength;\n    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n#ifdef HAZE\n    float fCameraAngle = dot(-worldSpaceRay, v3End) / length(v3End);\n    float fScaleCameraAngle = scale(fCameraAngle);\n    vec2 v2CameraOffset = fScaleCameraAngle*v2OpticalStartDepth;\n    float scaledValues = scale(fLightAngle) + fScaleCameraAngle;\n    vec2 v2ScaledValuesDepth = scaledValues * v2ScaleDepth;\n#else\n    float fCameraAngle = dot(worldSpaceRay, v3Start / length(v3Start));\n    float angleMultiplier = fCameraAngle>0.0?fCameraAngle:0.0;\n    float fScaleCameraAngle = scale(fCameraAngle);\n    vec2 v2CameraOffset = fScaleCameraAngle*v2OpticalStartDepth * v2ScaleDepth;\n#endif\n    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n    vec3 v3FrontColorBlue = vec3(0.0, 0.0, 0.0);\n    vec3 v3Attenuate= vec3(0.0, 0.0, 0.0);\n    vec3 v3AttenuateBlue = vec3(0.0, 0.0, 0.0);\n    for(int i=0; i<maxSamples; i++) {\n      float fHeight = length(v3SamplePoint);\n      float fAltitude = abs(fHeight - fInnerRadius);\n      vec2 v2Depth = exp(-fAltitude * v2ScaleOverScaleDepth);\n#ifdef HAZE\n      vec2 v2Scatter = v2Depth*v2ScaledValuesDepth-v2CameraOffset;\n#else\n      float fLightAngle = dot(v3LightDir, v3SamplePoint) / fHeight;\n      float fCameraAngle = dot(worldSpaceRay, v3SamplePoint) / fHeight;\n      float fTempScaledValues = scale(fLightAngle) - scale(fCameraAngle);\n      vec2 v2Scatter = v2CameraOffset + fTempScaledValues*v2Depth* v2ScaleDepth;\n#endif\n      v3Attenuate = exp(-v2Scatter.x * v3InvWavelengthScaled);\n      v3AttenuateBlue = exp(-v2Scatter.y * v3InvWavelengthScaled);\n      v3FrontColor += v3Attenuate * v2Depth.x;\n      v3FrontColorBlue += v3AttenuateBlue * v2Depth.y;\n      v3SamplePoint += v3SampleRay;\n    }\n    float fCos = clamp(dot(v3LightDir, -worldSpaceRay ),-0.9999999,1.0);\n    float fOnePlusCos2 = fCos*fCos + 1.0;\n#ifdef HAZE\n    vec3 colorCoefficients = (fScaledLength* 0.75 * fOnePlusCos2)*(fKrESun*v3InvWavelength+fKmESun);\n    vec3 v3Color = colorCoefficients *v3FrontColor;\n    vec3 v3ColorBlue = colorCoefficients *v3FrontColorBlue;\n#else\n    vec3 v3RayleighCoefficients = (fScaledLength*0.75 * fOnePlusCos2*fKrESun)*v3InvWavelength;\n    float fMieCoefficients = fScaledLength*fKmESun * fMiePhaseCoefficients * fOnePlusCos2 / pow(1.0 + fg2 - 2.0*fg*fCos, 1.5);\n    vec3 v3Color = v3RayleighCoefficients * v3FrontColor + fMieCoefficients * v3FrontColor;\n    vec3 v3ColorBlue = v3RayleighCoefficients * v3FrontColorBlue + fMieCoefficients * v3FrontColorBlue;\n#endif\n    vec3 ldrBlue = expTM(v3ColorBlue,2.0*fExposure);\n    vec3 ldrRed = expTM(v3Color,fExposure);\n    vec3 LDR = mix(ldrBlue,ldrRed,0.2);\n#ifdef HAZE\n    LDR *= (1.0-fCameraAngle);\n    vec3 hsv = rgb2hsv(LDR);\n    hsv.y = clamp(hsv.y*1.5,0.0,1.0);\n    LDR = hsv2rgb(hsv);\n    vec3 finalColor = LDR;\n#else\n    vec3 ldrReinhard = reinhardTM(v3Color,fExposure);\n    LDR += angleMultiplier*ldrReinhard;\n    float side = (rayEndT+rayStartT)*0.5;\n    float atmoHeight = sqrt(fCameraHeight2 - side*side);\n    float h2 = clamp(1.0-(atmoHeight-fLowerAlphaBlendBound)/(fOuterRadius-fLowerAlphaBlendBound),0.0,1.0);\n    vec3 finalColor = LDR*h2;\n    vec3 hsv = rgb2hsv(finalColor);\n    hsv.y = clamp(hsv.y*1.5,0.0,1.0);\n    finalColor = hsv2rgb(hsv);\n#endif\n#ifndef HAZE\n    float atmosStrength = clamp((length(ldrRed)-0.05)*1.05,0.0,1.0);\n    gl_FragColor = vec4(finalColor, atmosStrength*clamp(1.0-(atmoHeight-fInnerRadius)/(fOuterRadius-fInnerRadius),0.0,1.0));\n    if (fSurfaceBlend > 0.0) {\n      gl_FragColor = mix(gl_FragColor, surfaceColor, fSurfaceBlend);\n    }\n#else\n    gl_FragColor = vec4(finalColor, 1.0) * altitudeAlpha;\n#endif\n    if(showTest>0.0){\n      gl_FragColor = vec4(test,1.0);\n    }\n  } else {\n    gl_FragColor = vec4(0.0);\n  }\n}","realisticAtmosphere.vert":"#include <util/vsPrecision.glsl>\nuniform vec2 halfSizeNearPlane;\nuniform vec3 v3CameraUp;\nuniform vec3 v3CameraRight;\nuniform vec3 v3CameraDir;\nuniform vec2 v2CameraCenterOffset;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec3 v3WorldRay;\nvarying vec2 vtc;\n#ifdef HAZE\nvarying vec3 v3EyeDir;\n#endif\nvoid main(void) {\n  vec3 v3Pos = position;\n  vtc = uv0;\n  vec2 rayvtc = uv0 - v2CameraCenterOffset;\n#ifdef HAZE\n  v3EyeDir = vec3((2.0*halfSizeNearPlane *rayvtc)-halfSizeNearPlane,-1.0);\n#else\n  vec3 v3EyeDir = vec3((2.0*halfSizeNearPlane *rayvtc)-halfSizeNearPlane,-1.0);\n#endif\n  v3WorldRay = v3EyeDir.z*v3CameraDir + v3EyeDir.y*v3CameraUp + v3EyeDir.x*v3CameraRight;\n  gl_Position = vec4(v3Pos, 1.0);\n}","simpleAtmosphere.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nvarying vec2 vtc;\nvarying float falloff;\n#ifndef PANORAMIC\nuniform float altitudeFade;\nvarying float innerFactor;\n#endif\nvoid main() {\n  vec4 texColor = texture2D(tex, vtc);\n#ifdef PANORAMIC\n  gl_FragColor = texColor * falloff;\n#else\n  vec4 atmosphereColor = texColor * falloff;\n  vec4 innerColor = vec4(texColor.rgb * falloff, 1.0 - altitudeFade);\n  gl_FragColor = mix(atmosphereColor, innerColor, smoothstep(0.0, 1.0, innerFactor));\n#endif\n}","simpleAtmosphere.vert":"#include <util/vsPrecision.glsl>\nuniform mat4 proj;\nuniform mat4 view;\n#ifndef PANORAMIC\nconst float TWICEPI = 2.0*3.14159265;\nconst float ATMOSPHERE_RIM_SEGMENTS = 128.0;\nuniform vec3 silCircleCenter;\nuniform vec3 silCircleV1;\nuniform vec3 silCircleV2;\nuniform vec2 texV;\nuniform float innerScale;\nvarying float innerFactor;\n#endif\nuniform vec3 lightDirection;\nattribute vec3 position;\nvarying vec2 vtc;\nvarying float falloff;\nvoid main(void) {\n#ifdef PANORAMIC\n  vec3 pos = position;\n  float ndotl = lightDirection.z;\n  vtc = vec2(0.0, position.z+0.05);\n#else\n  innerFactor = clamp(-position.z, 0.0, 1.0);\n  float scale = position.y * (1.0 + innerFactor * innerScale);\n  float phi = position.x * (TWICEPI / ATMOSPHERE_RIM_SEGMENTS) + 1.0;\n  vec3 pos =  (silCircleCenter + sin(phi) * silCircleV1 + cos(phi) * silCircleV2) * scale;\n  float ndotl = dot(normalize(position.y > 0.0 ? pos: silCircleCenter), lightDirection);\n  vtc.x = position.x / ATMOSPHERE_RIM_SEGMENTS;\n  vtc.y = texV.x * (1.0 - position.z) + texV.y * position.z;\n#endif\n  falloff = max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));\n  gl_Position = proj * view * vec4(pos, 1.0);\n  gl_Position.z = gl_Position.w;\n}","simpleAtmosphereFade.frag":"#include <util/fsPrecision.glsl>\nvarying vec4 color;\nvoid main() {\n  gl_FragColor = color;\n}","simpleAtmosphereFade.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nuniform vec3 lightDirection;\nuniform vec3 cameraPosition;\nuniform float undergroundFadeAlpha;\nvarying vec4 color;\nvoid main(void) {\n  float ndotl = dot(normalize(cameraPosition), lightDirection);\n  float lighting = max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));\n  color = vec4(vec3(lighting), undergroundFadeAlpha);\n  gl_Position = vec4(position.xy, 1.0, 1.0);\n}","stars.frag":"#include <util/fsPrecision.glsl>\nvarying vec4 vcolor;\nvarying float vsize;\nvoid main() {\n  float cap = 0.7;\n  float scale = 1.0/cap;\n  float helper = clamp(length(abs(gl_PointCoord-vec2(0.5))),0.0,cap);\n  float alpha = clamp((cap-helper)*scale,0.0,1.0);\n  float intensity = alpha*alpha*alpha;\n  if (vsize < 3.0)\n    intensity *= 0.5;\n  gl_FragColor = vec4(1.0,1.0,1.0,intensity);\n  gl_FragColor.xyz *= vcolor.xyz;\n}","stars.vert":"#include <util/vsPrecision.glsl>\n#include <util/alignPixel.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform vec4 viewport;\nuniform float pixelRatio;\nattribute vec3 position;\nattribute vec4 color;\nattribute float size;\nvarying vec4 vcolor;\nvarying float vsize;\nvoid main(void) {\n  vec4 posProj = proj * view * model*vec4(position*1.0e25,1.0);\n  gl_Position = alignToPixelCenter(posProj, viewport.zw);\n  gl_Position.z = gl_Position.w;\n  vcolor = color / 1.2;\n  vsize = size * 5.0 * pixelRatio;\n  gl_PointSize = vsize;\n}"},materials:{checkerBoard:{"checkerBoard.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\nuniform vec2 size;\nuniform vec4 color1;\nuniform vec4 color2;\nvarying vec2 vUV;\nvoid main() {\n  vec2 uvScaled = vUV / (2.0 * size);\n  vec2 uv = fract(uvScaled - 0.25);\n  vec2 ab = clamp((abs(uv - 0.5) - 0.25) / fwidth(uvScaled), -0.5, 0.5);\n  float fade = smoothstep(0.25, 0.5, max(fwidth(uvScaled.x), fwidth(uvScaled.y)));\n  float t = mix(abs(ab.x + ab.y), 0.5, fade);\n  gl_FragColor = mix(color2, color1, t);\n}","checkerBoard.vert":"#include <util/vsPrecision.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec2 vUV;\nvoid main(void) {\n  vUV = uv0;\n  gl_Position = proj * view * vec4((model * vec4(position, 1.0)).xyz, 1.0);\n}"},color:{"color.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/slice.glsl>\nuniform vec4 eColor;\n#ifdef VERTEX_COLORS\nvarying vec4 vColor;\n#endif\nvarying vec3 vpos;\nvoid main() {\n  discardBySlice(vpos);\n#ifdef VERTEX_COLORS\n  gl_FragColor = vColor * eColor;\n#else\n  gl_FragColor = eColor;\n#endif\n  gl_FragColor = highlightSlice(gl_FragColor, vpos);\n}","color.vert":"#include <util/vsPrecision.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nattribute vec3 position;\n#ifdef VERTEX_COLORS\nattribute vec4 color;\nvarying vec4 vColor;\n#endif\nvarying vec3 vpos;\nvoid main(void) {\n#ifdef VERTEX_COLORS\n  vColor = color * 0.003921568627451;\n#endif\n  vpos = (model * vec4(position, 1.0)).xyz;\n  gl_Position = proj * view * vec4(vpos, 1.0);\n}"},defaultMaterial:{
"colorMixMode.glsl":"#include <util/color.glsl>\nvec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {\n  float symbolAlpha = 0.0;\n  const float maxTint = 85.0;\n  const float maxReplace = 170.0;\n  const float scaleAlpha = 3.0;\n  if (symbolColor.a > maxReplace) {\n    colorMixMode = 1;\n    symbolAlpha = scaleAlpha * (symbolColor.a - maxReplace);\n  } else if (symbolColor.a > maxTint) {\n    colorMixMode = 3;\n    symbolAlpha = scaleAlpha * (symbolColor.a - maxTint);\n  } else if (symbolColor.a > 0.0) {\n    colorMixMode = 0;\n    symbolAlpha = scaleAlpha * symbolColor.a;\n  } else {\n    colorMixMode = 1;\n    symbolAlpha = 0.0;\n  }\n  return vec4(symbolColor.r, symbolColor.g, symbolColor.b, symbolAlpha);\n}\nvec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {\n  vec3 internalMixed = internalColor * textureColor;\n  vec3 allMixed = internalMixed * externalColor;\n  if (mode == 1 ) {\n    return allMixed;\n  }\n  else if (mode == 2  ) {\n    return internalMixed;\n  }\n  else if (mode == 3  ) {\n    return externalColor;\n  }\n  else {\n    vec3 hsvIn = rgb2hsv(internalMixed);\n    vec3 hsvTint = rgb2hsv(externalColor);\n    vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, hsvIn.z * hsvTint.z);\n    return hsv2rgb(hsvOut);\n  }\n}\nfloat mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {\n  float internalMixed = internalOpacity * textureOpacity;\n  float allMixed = internalMixed * externalOpacity;\n  if (mode == 2  ) {\n    return internalMixed;\n  }\n  else if (mode == 3  ) {\n    return externalOpacity;\n  }\n  else {\n    return allMixed;\n  }\n}","colorPass.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/slice.glsl>\n#include <util/sceneLighting.glsl>\n#include <materials/defaultMaterial/texturingInputs.glsl>\n#define FRAGMENT_SHADER\n#include <materials/defaultMaterial/vertexTangents.glsl>\n#include <materials/defaultMaterial/textureNormals.glsl>\nuniform vec3 camPos;\nuniform vec3 localOrigin;\nuniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float opacity;\nuniform float layerOpacity;\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\nvarying mediump float colorMixMode;\n#else\nuniform int colorMixMode;\n#endif\n#ifdef RECEIVE_SHADOWS\nuniform sampler2D depthTex;\nuniform int shadowMapNum;\nuniform vec4 shadowMapDistance;\nuniform mat4 shadowMapMatrix[4];\nuniform float depthHalfPixelSz;\n#endif\n#ifdef RECEIVE_SSAO\nuniform sampler2D ssaoTex;\nuniform vec4 viewportPixelSz;\n#endif\nvarying vec3 vpos;\nvarying vec3 localvpos;\n#if (NORMALS == NORMALS_COMPRESSED) || (NORMALS == NORMALS_DEFAULT)\n  varying vec3 vnormal;\n#endif\n#if defined(VERTEXCOLORS)\nvarying vec4 vcolor;\n#endif\nvarying vec4 vcolorExt;\n#ifdef RECEIVE_SHADOWS\nvarying float linearDepth;\n#include <util/shadow.glsl>\n#endif\n#ifdef TREE_RENDERING\n  uniform mat4 view;\n#endif\n#ifdef USE_PBR\n    uniform float roughnessFactor;\n    uniform float metalnessFactor;\n    uniform vec3 emissionFactor;\n  #ifdef PBR_TEX_METALLNESS_ROUGHNESS\n    uniform sampler2D texMetallicRoughness;\n  #endif\n  #ifdef PBR_TEX_EMISSION\n    uniform sampler2D texEmission;\n  #endif\n  #ifdef PBR_TEX_OCCLUSION\n    uniform sampler2D texOcclusion;\n  #endif\n#endif\n#ifdef TEXTURING\n#include <materials/defaultMaterial/texturing.glsl>\n#endif\n#include <materials/defaultMaterial/colorMixMode.glsl>\nvoid main() {\n  discardBySlice(vpos);\n#if defined(TEXTURING) && defined(TEXTURE_COLOR)\n  vec4 texColor = textureLookup(tex, vtc);\n  #if defined(TEXTURE_ALPHA_PREMULTIPLIED)\n    texColor.rgb /= texColor.a;\n  #endif\n  discardOrAdjustTextureAlpha(texColor);\n#else\n  vec4 texColor = vec4(1.0);\n#endif\n  vec3 viewDir = vpos - camPos;\n#ifdef GROUND_NORMAL_SHADING\n  #if VIEWING_MODE == VIEWING_MODE_GLOBAL\n    vec3 normal = normalize(vpos + localOrigin);\n  #else\n    vec3 normal = vec3(0.0, 0.0, 1.0);\n  #endif\n#else\n  #if (NORMALS == NORMALS_SCREEN_DERIVATIVE)\n    vec3 normal = normalize(cross(dFdx(localvpos),dFdy(localvpos)));\n  #else\n    #ifdef DOUBLESIDED\n      vec3 normal = dot(vnormal, viewDir)>0.0 ? -vnormal : vnormal;\n    #elif defined(WINDINGORDERDOUBLESIDED)\n      vec3 normal = gl_FrontFacing ? vnormal : -vnormal;\n    #else\n      vec3 normal = vnormal;\n    #endif\n    normal = normalize(normal);\n  #endif\n#endif\n#ifdef USE_PBR\n    float roughness = roughnessFactor;\n    float metalness = metalnessFactor;\n  #ifdef PBR_TEX_METALLNESS_ROUGHNESS\n    vec3 metalicRoughness = texture2D(texMetallicRoughness, vtc).rgb;\n    roughness *= metalicRoughness.g ;\n    metalness *= metalicRoughness.b ;\n  #endif\n    vec3 emission = emissionFactor;\n  #ifdef PBR_TEX_EMISSION\n    emission *= texture2D(texEmission, vtc).rgb;\n  #endif\n    float bakedOcclusion = 1.0;\n  #ifdef PBR_TEX_OCCLUSION\n    bakedOcclusion *= texture2D(texOcclusion, vtc).r;\n  #endif\n#endif\n#ifdef RECEIVE_SSAO\n  float ssao = texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n  ssao = viewportPixelSz.z < 0.0 ? 1.0 : ssao;\n#else\n  float ssao = 1.0;\n#endif\n#ifdef USE_PBR\n  ssao *= bakedOcclusion;\n#endif\n  float additionalAmbientScale;\n  vec3 additionalLight = sceneLightingAdditionalLightGlobal(vpos + localOrigin, ssao, additionalAmbientScale);\n  float shadow = 0.0;\n#ifdef RECEIVE_SHADOWS\n  shadow = evalShadow(vpos, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\n#elif VIEWING_MODE == VIEWING_MODE_GLOBAL\n  shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n#endif\n  vec3 matColor = max(ambient, diffuse);\n#if defined(VERTEXCOLORS)\n  vec3 albedo_ = mixExternalColor(vcolor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n  float opacity_ = layerOpacity * mixExternalOpacity(vcolor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n#else\n  vec3 albedo_ = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n  float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n#endif\n  #if defined(TEXTURE_NORMALS)\n    #ifdef VERTEX_TANGENTS\n      mat3 tangentSpace = computeTangentSpace(normal);\n    #else\n      mat3 tangentSpace = computeTangentSpace(normal, vpos, vtc);\n    #endif\n    vec3 shadingNormal = computeTextureNormal(tangentSpace);\n  #else\n    vec3 shadingNormal = normal;\n  #endif\n  #ifdef TREE_RENDERING\n    shadingNormal = normalize(vnormal);\n    albedo_ *= 1.2;\n    vec3 viewForward = - vec3(view[0][2], view[1][2], view[2][2]);\n    float alignmentLightView = clamp(dot(-viewForward, lightingMainDirection), 0.0, 1.0);\n    float transmittance = 1.0 - clamp(dot(-viewForward, shadingNormal), 0.0, 1.0);\n    float treeRadialFalloff = vcolor.r;\n    float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);\n    additionalLight += backLightFactor * lightingMainIntensity;\n  #endif\n  #ifdef USE_PBR\n    vec3 normalGround = normalize(vpos + localOrigin);\n    vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, albedo_, shadow, 1.0 - ssao, additionalLight, viewDir, normalGround, roughness, metalness, emission);\n  #else\n    vec3 shadedColor = evaluateSceneLighting(shadingNormal, albedo_, shadow, 1.0 - ssao, additionalLight);\n  #endif\n  gl_FragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);\n}","colorPass.vert":"#include <util/vsPrecision.glsl>\n#include <materials/defaultMaterial/commonInputs.glsl>\n#define VERTEX_SHADER\n#include <materials/defaultMaterial/vertexTangents.glsl>\n#ifdef INSTANCEDCOLOR\nattribute vec4 instanceColor;\n#endif\nattribute vec3 position;\n#if (NORMALS == NORMALS_COMPRESSED)\n  attribute vec2 normalCompressed;\n  varying vec3 vnormal;\n#elif (NORMALS == NORMALS_DEFAULT)\n  attribute vec3 normal;\n  varying vec3 vnormal;\n#endif\nvarying vec3 vpos;\nvarying vec3 localvpos;\n#ifdef TEXTURE_COORDINATES\n    attribute vec2 uv0;\n    varying vec2 vtc;\n  #ifdef TEXTURE_ATLAS\n    attribute vec4 region;\n    varying vec4 regionV;\n  #endif\n#endif\n#ifdef COMPONENTCOLORS\n#include <materials/defaultMaterial/componentColors.glsl>\n#endif\n#ifdef RECEIVE_SHADOWS\nvarying float linearDepth;\n#endif\n#ifdef VERTEXCOLORS\nattribute vec4 color;\n#endif\n#ifdef SYMBOLVERTEXCOLORS\nattribute vec4 symbolColor;\n#endif\n#if defined(VERTEXCOLORS)\nvarying vec4 vcolor;\n#endif\nuniform vec4 externalColor;\nvarying vec4 vcolorExt;\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\nvarying mediump float colorMixMode;\n#endif\n#include <util/visualVariables.glsl>\n#if defined(VV_SIZE) || defined(VV_COLOR)\nattribute vec4 instanceFeatureAttribute;\n#endif\n#include <materials/defaultMaterial/colorMixMode.glsl>\n#include <materials/defaultMaterial/commonFunctions.glsl>\n#include <materials/defaultMaterial/constants.glsl>\n#include <materials/defaultMaterial/localCenter.glsl>\n#include <materials/defaultMaterial/localNormal.glsl>\nvoid main() {\n#ifdef VERTEXCOLORS\n  vcolor = color * 0.003921568627451;\n#endif\n  vcolorExt = externalColor;\n#ifdef INSTANCEDCOLOR\n  vcolorExt *= instanceColor;\n#endif\n#ifdef VV_COLOR\n  vcolorExt *= vvGetColor(instanceFeatureAttribute, vvColorValues, vvColorColors);\n#endif\n#ifdef SYMBOLVERTEXCOLORS\n  int symbolColorMixMode;\n  vcolorExt *= decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451;\n  colorMixMode = float(symbolColorMixMode) + 0.5;\n#endif\n#ifdef COMPONENTCOLORS\n  int symbolColorMixMode;\n  vcolorExt *= decodeSymbolColor(readComponentColor() * 255.0, symbolColorMixMode) * 0.003921568627451;\n  colorMixMode = float(symbolColorMixMode) + 0.5;\n#endif\n  if (vcolorExt.a < SYMBOL_ALPHA_CUTOFF) {\n    gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n  }\n  else {\n    vpos = calculateVPos();\n    localvpos = vpos - view[3].xyz;\n#ifdef INSTANCED_DOUBLE_PRECISION\n  #if (NORMALS == NORMALS_COMPRESSED) || (NORMALS == NORMALS_DEFAULT)\n    vnormal = normalize(modelNormal * localNormal().xyz);\n  #endif\n  vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n  #ifdef IOS_SAFARI_FIX\n    originDelta = originDelta - fract(originDelta * 1000000.0) * (1.0 / 1000000.0);\n  #endif\n  vpos -= originDelta;\n#else\n  #if (NORMALS == NORMALS_COMPRESSED) || (NORMALS == NORMALS_DEFAULT)\n    vnormal = normalize((modelNormal * localNormal()).xyz);\n  #endif\n#endif\n    #ifdef VERTICAL_OFFSET\n      vpos += calculateVerticalOffset(vpos, localOrigin);\n    #endif\n    #if defined(VERTEX_TANGENTS)\n      transformVertexTangent(mat3(modelNormal));\n    #endif\n    gl_Position = proj * view * vec4(vpos, 1.0);\n  }\n#ifdef RECEIVE_SHADOWS\n  linearDepth = gl_Position.w;\n#endif\n#ifdef TEXTURING\n  #ifndef FLIPV\n    vtc = uv0;\n  #else\n    vtc = vec2(uv0.x, 1.0-uv0.y);\n  #endif\n  #ifdef TEXTURE_ATLAS\n    regionV = region;\n  #endif\n#endif\n}","commonFunctions.glsl":"#include <materials/defaultMaterial/localPosition.glsl>\n#include <util/doublePrecision.glsl>\nvec3 calculateVPos() {\n#ifdef INSTANCED_DOUBLE_PRECISION\n  return model * localPosition().xyz;\n#else\n  return (model * localPosition()).xyz;\n#endif\n}\n#ifdef VERTICAL_OFFSET\n#ifdef SCREEN_SIZE_PERSPECTIVE\n#include <util/screenSizePerspective.glsl>\n#endif\nvec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n  float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);\n#if VIEWING_MODE == VIEWING_MODE_GLOBAL\n  vec3 worldNormal = normalize(worldPos + localOrigin);\n#else\n  vec3 worldNormal = vec3(0.0, 0.0, 1.0);\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float cosAngle = dot(worldNormal, normalize(worldPos - camPos));\n  float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);\n#else\n  float verticalOffsetScreenHeight = verticalOffset.x;\n#endif\n  float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\n  return worldNormal * worldOffset;\n}\n#endif","commonInputs.glsl":"uniform mat4 proj;\nuniform mat4 view;\n#ifdef INSTANCED_DOUBLE_PRECISION\nuniform vec3 viewOriginHi;\nuniform vec3 viewOriginLo;\n#endif\nuniform vec3 camPos;\nuniform vec3 localOrigin;\n#ifdef INSTANCED\n#ifdef INSTANCED_DOUBLE_PRECISION\nattribute vec3 modelOriginHi;\nattribute vec3 modelOriginLo;\nattribute mat3 model;\nattribute mat3 modelNormal;\n#else\nattribute mat4 model;\nattribute mat4 modelNormal;\n#endif\n#else\nuniform mat4 model;\nuniform mat4 modelNormal;\n#endif\n#ifdef VERTICAL_OFFSET\nuniform vec4 verticalOffset;\n#ifdef SCREEN_SIZE_PERSPECTIVE\nuniform vec4 screenSizePerspectiveAlignment;\n#endif\n#endif","componentColors.glsl":"uniform sampler2D uComponentColorTex;\nuniform vec2 uComponentColorTexInvDim;\nattribute float componentIndex;\nvec4 readComponentColor() {\n  float normalizedIndex = (componentIndex + 0.5) * uComponentColorTexInvDim.x;\n  vec2 indexCoord = vec2(\n    mod(normalizedIndex, 1.0),\n    (floor(normalizedIndex) + 0.5) * uComponentColorTexInvDim.y\n  );\n  vec4 componentColor = texture2D(uComponentColorTex, indexCoord);\n  return vec4( componentColor.r, componentColor.g, componentColor.b - mod(componentColor.b*255.0, 2.0)/255.0, componentColor.a);\n}\nbool readComponentCastShadowsFlag(){\n  float normalizedIndex = (componentIndex + 0.5) * uComponentColorTexInvDim.x;\n  vec2 indexCoord = vec2(\n    mod(normalizedIndex, 1.0),\n    (floor(normalizedIndex) + 0.5) * uComponentColorTexInvDim.y\n  );\n  if( mod(texture2D(uComponentColorTex, indexCoord).b*255.0, 2.0) < 1.0 )\n      return false;\n  return true;\n}","constants.glsl":"#define SYMBOL_ALPHA_CUTOFF 0.001","depthPass.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/encoding.glsl>\n#include <util/depth.glsl>\n#include <util/slice.glsl>\nvarying float depth;\nvarying vec3 vpos;\n#if defined(TEXTURING)\n  #include <materials/defaultMaterial/texturingInputs.glsl>\n  #include <materials/defaultMaterial/texturing.glsl>\n#endif\nvoid main() {\n  discardBySlice(vpos);\n  #if defined(TEXTURING)\n    vec4 texColor = textureLookup(tex, vtc);\n    discardOrAdjustTextureAlpha(texColor);\n  #endif\n  #ifndef BIAS_SHADOWMAP\n    gl_FragColor = float2rgba(depth);\n  #else\n    gl_FragColor = float2rgba(calcFragDepth(depth));\n  #endif\n}","depthPass.vert":"#include <util/vsPrecision.glsl>\n#include <materials/defaultMaterial/commonInputs.glsl>\nuniform vec2 nearFar;\nattribute vec3 position;\nvarying float depth;\nvarying vec3 vpos;\n#ifdef TEXTURING\nattribute vec2 uv0;\nvarying vec2 vtc;\n#ifdef TEXTURE_ATLAS\nattribute vec4 region;\nvarying vec4 regionV;\n#endif\n#endif\n#include <util/visualVariables.glsl>\n#if defined(VV_CUSTOM_MODEL_MATRIX)\nattribute vec4 instanceFeatureAttribute;\n#endif\n#include <materials/defaultMaterial/commonFunctions.glsl>\n#include <materials/defaultMaterial/localCenter.glsl>\n#if defined(COMPONENTCOLORS)\n#include <materials/defaultMaterial/componentColors.glsl>\n#endif\nvoid main(void) {\n  vpos = calculateVPos();\n#if defined(COMPONENTCOLORS)\n  if( !readComponentCastShadowsFlag() ){\n    gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n  }else\n  {\n#endif\n#ifdef INSTANCED_DOUBLE_PRECISION\n  vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n#ifdef IOS_SAFARI_FIX\n  originDelta = originDelta - fract(originDelta * 1000000.0) * (1.0 / 1000000.0);\n#endif\n  vpos -= originDelta;\n#endif\n  #ifdef VERTICAL_OFFSET\n    vpos += calculateVerticalOffset(vpos, localOrigin);\n  #endif\n  vec4 eye = view * vec4(vpos, 1.0);\n  gl_Position = proj * eye;\n  depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\n#if defined(COMPONENTCOLORS)\n  }\n#endif\n#ifdef TEXTURING\n#ifndef FLIPV\n  vtc = uv0;\n#else\n  vtc = vec2(uv0.x, 1.0-uv0.y);\n#endif\n#ifdef TEXTURE_ATLAS\n  regionV = region;\n#endif\n#endif\n}","highlightPass.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/slice.glsl>\n#include <util/highlight.glsl>\nvarying vec3 vpos;\nuniform sampler2D depthTex;\nuniform vec4 highlightViewportPixelSz;\n#if defined(TEXTURING)\n  #include <materials/defaultMaterial/texturingInputs.glsl>\n  #include <materials/defaultMaterial/texturing.glsl>\n#endif\nvoid main() {\n  discardBySlice(vpos);\n  #if defined(TEXTURING)\n    vec4 texColor = textureLookup(tex, vtc);\n    discardOrAdjustTextureAlpha(texColor);\n  #endif\n  gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n}","highlightPass.vert":"#include <util/vsPrecision.glsl>\n#include <materials/defaultMaterial/commonInputs.glsl>\nattribute vec3 position;\nvarying vec3 vpos;\n#ifdef TEXTURING\nattribute vec2 uv0;\nvarying vec2 vtc;\n#ifdef TEXTURE_ATLAS\nattribute vec4 region;\nvarying vec4 regionV;\n#endif\n#endif\n#include <util/visualVariables.glsl>\n#if defined(VV_CUSTOM_MODEL_MATRIX)\nattribute vec4 instanceFeatureAttribute;\n#endif\n#include <materials/defaultMaterial/commonFunctions.glsl>\n#include <materials/defaultMaterial/localCenter.glsl>\nvoid main(void) {\n  vpos = calculateVPos();\n#ifdef INSTANCED_DOUBLE_PRECISION\n  vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n#ifdef IOS_SAFARI_FIX\n  originDelta = originDelta - fract(originDelta * 1000000.0) * (1.0 / 1000000.0);\n#endif\n  vpos -= originDelta;\n#endif\n  #ifdef VERTICAL_OFFSET\n    vpos += calculateVerticalOffset(vpos, localOrigin);\n  #endif\n  gl_Position = proj * view * vec4(vpos, 1.0);\n#ifdef TEXTURING\n#ifndef FLIPV\n  vtc = uv0;\n#else\n  vtc = vec2(uv0.x, 1.0-uv0.y);\n#endif\n#ifdef TEXTURE_ATLAS\n  regionV = region;\n#endif\n#endif\n}","localCenter.glsl":"#ifdef VV_CUSTOM_MODEL_MATRIX\n# ifdef VERTICAL_OFFSET\nvec4 localCenter() { return vvTransformPosition(vec3(0.0), instanceFeatureAttribute); }\n# endif\n#else\n# ifdef VERTICAL_OFFSET\nvec4 localCenter() { return vec4(vec3(0.0), 1.0); }\n# endif\n#endif","localNormal.glsl":"#include <util/normalEncoding.glsl>\n#ifdef VV_CUSTOM_MODEL_MATRIX\n  # if (NORMALS == NORMALS_COMPRESSED)\n    vec4 localNormal() { return vvTransformNormal(decodeNormal(normalCompressed), instanceFeatureAttribute); }\n  # elif (NORMALS == NORMALS_DEFAULT)\n    vec4 localNormal() { return vvTransformNormal(normal, instanceFeatureAttribute); }\n  # endif\n#else\n  # if (NORMALS == NORMALS_COMPRESSED)\n    vec4 localNormal() { return vec4(decodeNormal(normalCompressed), 1.0); }\n  # elif (NORMALS == NORMALS_DEFAULT)\n    vec4 localNormal() { return vec4(normal, 1.0); }\n  # endif\n#endif","localPosition.glsl":"#ifdef VV_CUSTOM_MODEL_MATRIX\nvec4 localPosition() { return vvTransformPosition(position, instanceFeatureAttribute); }\n#else\nvec4 localPosition() { return vec4(position, 1.0); }\n#endif","normalPass.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/slice.glsl>\n#if (NORMALS == NORMALS_COMPRESSED) || (NORMALS == NORMALS_DEFAULT)\n  varying vec3 vnormal;\n#endif\nvarying vec3 vpos;\nvarying vec3 vPositionView;\n#if defined(TEXTURING)\n  #include <materials/defaultMaterial/texturingInputs.glsl>\n  #include <materials/defaultMaterial/texturing.glsl>\n#endif\nvoid main() {\n  discardBySlice(vpos);\n  #if defined(TEXTURING)\n    vec4 texColor = textureLookup(tex, vtc);\n    discardOrAdjustTextureAlpha(texColor);\n  #endif\n#if (NORMALS == NORMALS_SCREEN_DERIVATIVE)\n  vec3 normal = normalize(cross(dFdx(vPositionView),dFdy(vPositionView)));\n#else\n  vec3 normal = normalize(vnormal);\n  if (gl_FrontFacing == false) normal = -normal;\n#endif\n  #ifndef ALPHA_ZERO\n    gl_FragColor = vec4(vec3(.5) + .5 * normal, 1.0);\n  #else\n    gl_FragColor = vec4(vec3(.5) + .5 * normal, 0.0);\n  #endif\n}","normalPass.vert":"#include <util/vsPrecision.glsl>\n#include <materials/defaultMaterial/commonInputs.glsl>\nuniform mat4 viewNormal;\nattribute vec3 position;\n#if (NORMALS == NORMALS_COMPRESSED)\n  attribute vec2 normalCompressed;\n  varying vec3 vnormal;\n#elif (NORMALS == NORMALS_DEFAULT)\n  attribute vec3 normal;\n  varying vec3 vnormal;\n#endif\n#ifdef TEXTURING\nattribute vec2 uv0;\nvarying vec2 vtc;\n#ifdef TEXTURE_ATLAS\nattribute vec4 region;\nvarying vec4 regionV;\n#endif\n#endif\nvarying vec3 vpos;\nvarying vec3 vPositionView;\n#include <util/visualVariables.glsl>\n#if defined(VV_CUSTOM_MODEL_MATRIX)\nattribute vec4 instanceFeatureAttribute;\n#endif\n#include <materials/defaultMaterial/commonFunctions.glsl>\n#include <materials/defaultMaterial/localCenter.glsl>\n#include <materials/defaultMaterial/localNormal.glsl>\nvoid main(void) {\n  vpos = calculateVPos();\n#ifdef INSTANCED_DOUBLE_PRECISION\n  #if (NORMALS == NORMALS_COMPRESSED) || (NORMALS == NORMALS_DEFAULT)\n    vnormal = normalize((viewNormal * vec4(modelNormal * localNormal().xyz, 1.0)).xyz);\n  #endif\n  vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n  #ifdef IOS_SAFARI_FIX\n    originDelta = originDelta - fract(originDelta * 1000000.0) * (1.0 / 1000000.0);\n  #endif\n  vpos -= originDelta;\n#else\n  #if (NORMALS == NORMALS_COMPRESSED) || (NORMALS == NORMALS_DEFAULT)\n    vnormal = normalize((viewNormal * modelNormal * localNormal()).xyz);\n  #endif\n#endif\n  #ifdef VERTICAL_OFFSET\n    vpos += calculateVerticalOffset(vpos, localOrigin);\n  #endif\n  vPositionView = (view * vec4(vpos, 1.0)).xyz;\n  gl_Position = proj * vec4(vPositionView, 1.0);\n#ifdef TEXTURING\n#ifndef FLIPV\n  vtc = uv0;\n#else\n  vtc = vec2(uv0.x, 1.0-uv0.y);\n#endif\n#ifdef TEXTURE_ATLAS\n  regionV = region;\n#endif\n#endif\n}","textureNormals.glsl":"#if defined(TEXTURE_NORMALS)\n  uniform sampler2D texNormal;\n  vec3 computeTextureNormal(mat3 tangentSpace) {\n    vec3 rawNormal = texture2D(texNormal, vtc).rgb * 2.0 - 1.0;\n    return tangentSpace * rawNormal;\n  }\n#endif","texturing.glsl":"float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\n  float deltaMaxSqr = max(dot(ddx, ddx), dot(ddy, ddy));\n  return max(0.0, 0.5 * log2(deltaMaxSqr));\n}\nvec4 textureAtlasLookup(sampler2D tex, vec2 uv, vec4 region, vec2 texSize) {\n  vec2 atlasScale = region.zw - region.xy;\n  vec2 uvAtlas = fract(uv) * atlasScale + region.xy;\n  vec4 texColor;\n  vec2 dUVdx = dFdx(uv) * atlasScale;\n  vec2 dUVdy = dFdy(uv) * atlasScale;\n#ifdef GL_EXT_shader_texture_lod\n  return texture2DGradEXT(tex, uvAtlas, dUVdx, dUVdy);\n#else\n  vec2 dUVdxAuto = dFdx(uvAtlas);\n  vec2 dUVdyAuto = dFdy(uvAtlas);\n  float mipMapLevel = calcMipMapLevel(dUVdx * texSize, dUVdy * texSize);\n  float autoMipMapLevel = calcMipMapLevel(dUVdxAuto * texSize, dUVdyAuto * texSize);\n  return texture2D(tex, uvAtlas, mipMapLevel - autoMipMapLevel);\n#endif\n}\nvec4 textureLookup(sampler2D tex, vec2 uv) {\n#ifdef TEXTURE_ATLAS\n  return textureAtlasLookup(tex, uv, regionV, texSize);\n#else\n  return texture2D(tex, uv);\n#endif\n}\nvoid discardOrAdjustTextureAlpha(inout vec4 texColor) {\n  #if defined(TEXTURE_ALPHA_MODE_MASK)\n    if (texColor.a < textureAlphaCutoff) {\n      discard;\n    } else {\n      texColor.a = 1.0;\n    }\n  #elif defined(TEXTURE_ALPHA_MODE_MASK_BLEND)\n    if (texColor.a < textureAlphaCutoff) {\n      discard;\n    }\n  #elif defined(TEXTURE_ALPHA_MODE_OPAQUE)\n    texColor.a = 1.0;\n  #else\n  #endif\n}","texturingInputs.glsl":"#ifdef TEXTURING\n  uniform sampler2D tex;\n  uniform vec2 texSize;\n  #if defined(TEXTURE_ALPHA_MODE_MASK) || defined(TEXTURE_ALPHA_MODE_MASK_BLEND)\n  uniform float textureAlphaCutoff;\n  #endif\n  #ifdef TEXTURE_ATLAS\n  varying vec4 regionV;\n  #endif\n#endif\n#if defined(TEXTURING) || defined(TEXTURE_COORDINATES)\nvarying vec2 vtc;\n#endif","vertexTangents.glsl":"#if defined(VERTEX_SHADER)\n  #if defined(VERTEX_TANGENTS)\n    attribute vec4 aTangent;\n    varying vec4 vTangent;\n    void transformVertexTangent(mat3 modelTransformForNormals) {\n      vTangent.xyz = modelTransformForNormals * aTangent.xyz;\n      vTangent.w = aTangent.w;\n    }\n  #endif\n#elif defined(FRAGMENT_SHADER)\n  #if defined(VERTEX_TANGENTS)\n    varying vec4 vTangent;\n    #if defined(WINDINGORDERDOUBLESIDED)\n      mat3 computeTangentSpace(vec3 normal) {\n        float tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;\n        vec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);\n        vec3 bitangent = cross(normal, tangent) * tangentHeadedness;\n        return mat3(tangent, bitangent, normal);\n      }\n    #else\n      mat3 computeTangentSpace(vec3 normal) {\n        float tangentHeadedness = vTangent.w;\n        vec3 tangent = normalize(vTangent.xyz);\n        vec3 bitangent = cross(normal, tangent) * tangentHeadedness;\n        return mat3(tangent, bitangent, normal);\n      }\n    #endif\n  #else\n    mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {\n      vec3 Q1 = dFdx(pos);\n      vec3 Q2 = dFdy(pos);\n      vec2 stx = dFdx(st);\n      vec2 sty = dFdy(st);\n      vec3 T = (sty.t * Q1 - stx.t * Q2) / (stx.s * sty.t - sty.s * stx.t);\n      T = normalize(T - normal * dot(normal, T));\n      vec3 B = normalize(cross(normal, T));\n      float det = sty.t * stx.s - stx.t * sty.s;\n      if(det > 0.0){\n        T *= -1.0;\n      }\n      return mat3(T, B, normal);\n    }\n  #endif\n#endif"},hud:{"colorPass.frag":"#include <materials/hud/hudHeader.glsl>\nvoid main() {\n#include <materials/hud/hudMain.glsl>\n}","highlightPass.frag":"#include <materials/hud/hudHeader.glsl>\n#include <util/highlight.glsl>\nuniform sampler2D depthTex;\nuniform vec4 highlightViewportPixelSz;\nvoid main() {\n#include <materials/hud/hudMain.glsl>\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\n  if (voccluded == 1.0) {\n    gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n  } else {\n    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n  }\n#else\n  gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n#endif\n}","hud.vert":"#include <util/vsPrecision.glsl>\n#include <util/alignPixel.glsl>\n#include <util/hud.glsl>\n#include <util/visualVariables.glsl>\n#include <util/slice.glsl>\nuniform vec2 screenOffset;\nuniform vec2 anchorPos;\nuniform vec2 textureCoordinateScaleFactor;\n#ifdef SCREEN_SIZE_PERSPECTIVE\nuniform vec4 screenSizePerspective;\n#endif\n#ifdef DEBUG_DRAW_BORDER\nvarying vec4 debugBorderCoords;\n#endif\nattribute vec2 uv0;\nattribute vec4 color;\nattribute vec2 size;\nattribute vec4 auxpos2;\nvarying vec4 vcolor;\nvarying vec2 vtc;\nvarying vec2 vsize;\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\nvarying float voccluded;\n#endif\nvoid main(void) {\n  ProjectHUDAux projectAux;\n  vec4 posProj = projectPositionHUD(projectAux);\n  if (rejectBySlice(projectAux.posModel)) {\n    gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    return;\n  }\n  vec2 inputSize;\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);\n  vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n#else\n  inputSize = size;\n  vec2 screenOffsetScaled = screenOffset;\n#endif\n#ifdef VV_SIZE\n  inputSize *= vvGetScale(auxpos2).xx;\n#endif\n  vec2 combinedSize = inputSize * pixelRatio;\n  vec4 quadOffset = vec4(0.0);\n#if defined(OCCL_TEST) || defined(BINARY_HIGHLIGHT_OCCLUSION)\n  bool visible = testVisibilityHUD(posProj);\n#endif\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\nvoccluded = visible ? 0.0 : 1.0;\n#endif\n#ifdef OCCL_TEST\n  if (visible) {\n#endif\n    vec2 uv01 = floor(uv0);\n    vec2 uv = uv0 - uv01;\n    quadOffset.xy = ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;\n#ifdef SIGNED_DISTANCE_FIELD\n    posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;\n#else\n    posProj += quadOffset;\n    if (inputSize.x == size.x) {\n      posProj = alignToPixelOrigin(posProj, viewport.zw);\n    }\n#endif\n    gl_Position = posProj;\n    vtc = uv * textureCoordinateScaleFactor;\n#ifdef DEBUG_DRAW_BORDER\n    debugBorderCoords = vec4(uv01, 1.5 / combinedSize);\n#endif\n    vsize = inputSize;\n#ifdef OCCL_TEST\n  } else {\n    vtc = vec2(.0);\n#ifdef DEBUG_DRAW_BORDER\n    debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);\n#endif\n  }\n#endif\n  gl_Position = posProj;\n#ifdef VV_COLOR\n  vcolor = vvGetColor(auxpos2, vvColorValues, vvColorColors);\n#else\n  vcolor = color / 255.0;\n#endif\n}","hudHeader.glsl":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/encoding.glsl>\n#include <util/color.glsl>\nuniform sampler2D tex;\nuniform vec4 overrideColor;\nuniform vec4 outlineColor;\nuniform float outlineSize;\nvarying vec4 vcolor;\nvarying vec2 vtc;\nvarying vec2 vsize;\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\nvarying float voccluded;\n#endif\n#ifdef DEBUG_DRAW_BORDER\nvarying vec4 debugBorderCoords;\n#endif","hudMain.glsl":"#ifdef SIGNED_DISTANCE_FIELD\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n  vec4 fillPixelColor = overrideColor * vcolor;\n  const float txSize = 128.0;\n  const float texelSize = 1.0 / txSize;\n  vec2 scaleFactor = (vsize - txSize) * texelSize;\n  vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;\n  float d = rgba2float(texture2D(tex, samplePos)) - 0.5;\n  float dist = d * vsize.x;\n  fillPixelColor.a *= clamp(0.5 - dist, 0.0, 1.0);\n  if (outlineSize > 0.25) {\n    vec4 outlinePixelColor = outlineColor;\n    float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);\n    outlinePixelColor.a *= clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\n    float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\n    vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +\n      vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\n    gl_FragColor = vec4(compositeColor, compositeAlpha);\n  }\n  else {\n    gl_FragColor = premultiplyAlpha(fillPixelColor);\n  }\n#else\n  gl_FragColor = texture2D(tex, vtc, -0.5) * premultiplyAlpha(overrideColor * vcolor);\n#endif\n#ifdef DEBUG_DRAW_BORDER\n   float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));\n   gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder);\n#endif\n  if (gl_FragColor.a < 0.1) {\n    discard;\n  }","occlusionTest.frag":"#include <util/fsPrecision.glsl>\nuniform vec4 color;\nvoid main() {\n  gl_FragColor = color;\n}","occlusionTest.vert":"#include <util/vsPrecision.glsl>\n#include <util/alignPixel.glsl>\n#include <util/hud.glsl>\n#include <util/slice.glsl>\nvoid main(void) {\n  vec4 posProjCenter;\n  if (dot(position, position) > 0.0) {\n    ProjectHUDAux projectAux;\n    vec4 posProj = projectPositionHUD(projectAux);\n    posProjCenter = alignToPixelCenter(posProj, viewport.zw);\n    vec3 vpos = projectAux.posModel;\n    if (rejectBySlice(vpos)) {\n      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n  }\n  else {\n    posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n  }\n  gl_Position = posProjCenter;\n  gl_PointSize = 1.0;\n}"},lineCallout:{"lineCallout.frag":"#include <util/fsPrecision.glsl>\nuniform vec4 color;\nuniform vec4 borderColor;\nvarying vec4 coverageSampling;\nvarying vec2 lineSizes;\nvoid main() {\n  vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n  float borderAlpha = color.a * borderColor.a * coverage.y;\n  float colorAlpha = color.a * coverage.x;\n  float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n#ifdef DEPTH_HUD\n  if (finalAlpha < 0.01) {\n    discard;\n  }\n#else\n  vec3 finalRgb = mix(borderColor.rgb * borderAlpha, color.rgb, colorAlpha);\n  gl_FragColor = vec4(finalRgb, finalAlpha);\n#endif\n}",
"lineCallout.vert":"#include <util/vsPrecision.glsl>\n#include <util/alignPixel.glsl>\n#include <util/hud.glsl>\n#include <util/slice.glsl>\nattribute vec2 uv0;\nuniform float lineSize;\nuniform vec2 pixelToNDC;\nuniform float borderSize;\nuniform vec2 screenOffset;\nvarying vec4 coverageSampling;\nvarying vec2 lineSizes;\nvoid main(void) {\n  ProjectHUDAux projectAux;\n  vec4 endPoint = projectPositionHUD(projectAux);\n  vec3 vpos = projectAux.posModel;\n  if (rejectBySlice(vpos)) {\n    gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n    return;\n  }\n#ifdef OCCL_TEST\n  if (!testVisibilityHUD(endPoint)) {\n    gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n    return;\n  }\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n  vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);\n#else\n  vec2 screenOffsetScaled = screenOffset;\n#endif\n  vec3 posView = (view * (model * vec4(position, 1.0))).xyz;\n  applyHUDViewDependentPolygonOffset(auxpos1.w, projectAux.absCosAngle, posView);\n  vec4 startPoint = proj * vec4(posView, 1.0);\n  vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n  startPoint.xy += screenOffsetNorm * startPoint.w;\n  endPoint.xy += screenOffsetNorm * endPoint.w;\n  vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n  vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n#ifdef DEPTH_HUD\n#ifdef DEPTH_HUD_ALIGN_START\n  endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);\n#else\n  startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);\n#endif\n#endif\n  vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\n  vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n  vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n  float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);\n#else\n  float lineSizeScaled = lineSize;\n  float borderSizeScaled = borderSize;\n#endif\n  float halfPixelSize = lineSizeScaled * 0.5;\n  float halfWholePixelSize = floor(lineSizeScaled) * 0.5;\n  float halfPixelSizeInt = floor(halfWholePixelSize);\n  float subpixelOffset = -fract(lineSizeScaled) * float(halfWholePixelSize > 0.0);\n  float pixelOffset = -halfPixelSizeInt + subpixelOffset;\n  float padding = 1.0 + borderSizeScaled;\n  vec2 ndcOffset = (pixelOffset - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n  projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n  float edgeDirection = (uv0.x * 2.0 - 1.0);\n  float halfBorderSize = 0.5 * borderSizeScaled;\n  float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n  float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n  float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n  coverageSampling = vec4(\n    outerEdgeCoverageSampler,\n    outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n    halfPixelSize - 0.5,\n    halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n  );\n  lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n  gl_Position = projectedPosition;\n}"},measurementArrow:{"measurementArrow.frag":"#include <util/fsPrecision.glsl>\nuniform float outlineSize;\nuniform vec4 outlineColor;\nuniform float stripeLength;\nuniform vec4 stripeEvenColor;\nuniform vec4 stripeOddColor;\nvarying vec2 vtc;\nvarying float vlength;\nvarying float vradius;\n#define INV_SQRT2 (1.0 / sqrt(2.0))\nvec4 arrowColor(vec2 tc, float len) {\n  float d = INV_SQRT2 * (tc.x - abs(tc.y));\n  d = min(d, INV_SQRT2 * (len - tc.x - abs(tc.y)));\n  d = min(d, 1.0 - abs(tc.y));\n  if (d < 0.0) {\n    return vec4(0.0);\n  } else if (d < outlineSize) {\n    return outlineColor;\n  } else {\n    return fract(0.5 / stripeLength * tc.x * vradius) >= 0.5 ? stripeOddColor : stripeEvenColor;\n  }\n}\nvoid main(void) {\n  vec2 ntc = vec2(vtc.x / vradius, vtc.y);\n  vec4 color = arrowColor(ntc, vlength / vradius);\n  if (color.a == 0.0) {\n    discard;\n  }\n  gl_FragColor = color;\n}","measurementArrow.vert":"#include <util/vsPrecision.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform float width;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv0;\nattribute float auxpos1;\nvarying vec2 vtc;\nvarying float vlength;\nvarying float vradius;\nvoid main(void) {\n  vec3 bitangent = normal;\n  vtc = uv0;\n  vlength = auxpos1;\n  vradius = 0.5 * width;\n  vec4 pos = view * vec4((model * vec4(position + vradius * bitangent * uv0.y, 1.0)).xyz, 1.0);\n  gl_Position = proj * pos;\n}"},nativeLine:{"colorPass.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/slice.glsl>\nuniform vec4 constantColor;\nvarying vec3 vpos;\n#ifdef VERTEXCOLORS\nvarying vec4 vcolor;\n#endif\nvoid main() {\n  discardBySlice(vpos);\n#ifdef VERTEXCOLORS\n  gl_FragColor = highlightSlice(vcolor, vpos);\n#else\n  gl_FragColor = highlightSlice(constantColor, vpos);\n#endif\n}","highlightPass.frag":"#include <util/fsPrecision.glsl>\n#include <util/slice.glsl>\n#include <util/highlight.glsl>\nvarying vec3 vpos;\nuniform sampler2D depthTex;\nuniform vec4 highlightViewportPixelSz;\nvoid main() {\n  discardBySlice(vpos);\n  gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n}","nativeLine.vert":"#include <util/vsPrecision.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nattribute vec3 position;\n#ifdef VERTEXCOLORS\nattribute vec4 color;\n#endif\nvarying vec3 vpos;\n#ifdef VERTEXCOLORS\nvarying vec4 vcolor;\n#endif\nvoid main(void) {\n  vpos = (model * vec4(position, 1.0)).xyz;\n  #ifdef VERTEXCOLORS\n    vcolor = color * 0.003921568627451;\n  #endif\n  gl_Position = proj * view * vec4(vpos, 1.0);\n}"},pathMaterial:{"colorMixMode.glsl":"#include <util/color.glsl>\nvec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {\n  float symbolAlpha = 0.0;\n  const float maxTint = 85.0;\n  const float maxReplace = 170.0;\n  const float scaleAlpha = 3.0;\n  if (symbolColor.a == 0.0) {\n    colorMixMode = 1;\n    symbolAlpha = 0.0;\n  }\n  else if (symbolColor.a <= maxTint) {\n    colorMixMode = 0;\n    symbolAlpha = scaleAlpha * symbolColor.a;\n  }\n  else if (symbolColor.a <= maxReplace) {\n    colorMixMode = 3;\n    symbolAlpha = scaleAlpha * (symbolColor.a - maxTint);\n  }\n  else {\n    colorMixMode = 1;\n    symbolAlpha = scaleAlpha * (symbolColor.a - maxReplace);\n  }\n  return vec4(symbolColor.rgb, symbolAlpha);\n}\nvec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {\n  vec3 internalMixed = internalColor * textureColor;\n  vec3 allMixed = internalMixed * externalColor;\n  if (mode == 1 ) {\n    return allMixed;\n  }\n  else if (mode == 2  ) {\n    return internalMixed;\n  }\n  else if (mode == 3  ) {\n    return externalColor;\n  }\n  else {\n    vec3 hsvIn = rgb2hsv(internalMixed);\n    vec3 hsvTint = rgb2hsv(externalColor);\n    vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, hsvIn.z * hsvTint.z);\n    return hsv2rgb(hsvOut);\n  }\n}\nfloat mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {\n  float internalMixed = internalOpacity * textureOpacity;\n  float allMixed = internalMixed * externalOpacity;\n  if (mode == 2  ) {\n    return internalMixed;\n  }\n  else if (mode == 3  ) {\n    return externalOpacity;\n  }\n  else {\n    return allMixed;\n  }\n}","colorPass.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/slice.glsl>\n#include <util/sceneLighting.glsl>\nuniform vec3 camPos;\nuniform vec3 localOrigin;\nuniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float opacity;\nuniform float layerOpacity;\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\nvarying mediump float colorMixMode;\n#else\nuniform int colorMixMode;\n#endif\n#ifdef RECEIVE_SHADOWS\nuniform sampler2D depthTex;\nuniform int shadowMapNum;\nuniform vec4 shadowMapDistance;\nuniform mat4 shadowMapMatrix[4];\nuniform float depthHalfPixelSz;\n#endif\n#ifdef RECEIVE_SSAO\nuniform sampler2D ssaoTex;\nuniform vec4 viewportPixelSz;\n#endif\nvarying vec3 vpos;\nvarying vec3 vnormal;\nvarying vec4 vcolor;\nvarying vec4 vcolorExt;\n#ifdef RECEIVE_SHADOWS\nvarying float linearDepth;\n#include <util/shadow.glsl>\n#endif\n#include <materials/pathMaterial/colorMixMode.glsl>\nvoid main() {\n  discardBySlice(vpos);\n  vec4 texColor = vec4(1.0);\n  vec3 viewDir = vpos - camPos;\n#ifdef GROUND_NORMAL_SHADING\n#if VIEWING_MODE == VIEWING_MODE_GLOBAL\n  vec3 normal = normalize(vpos + localOrigin);\n#else\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n#endif\n#else\n#ifdef DOUBLESIDED\n  vec3 normal = dot(vnormal, viewDir)>0.0 ? -vnormal : vnormal;\n#elif defined(WINDINGORDERDOUBLESIDED)\n  vec3 normal = gl_FrontFacing ? vnormal : -vnormal;\n#else\n  vec3 normal = vnormal;\n#endif\n  normal = normalize(normal);\n#endif\n#ifdef RECEIVE_SSAO\n  float ssao = texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n  ssao = viewportPixelSz.z < 0.0 ? 1.0 : ssao;\n#else\n  float ssao = 1.0;\n#endif\n  float additionalAmbientScale;\n  vec3 additionalLight = sceneLightingAdditionalLightGlobal(vpos + localOrigin, ssao, additionalAmbientScale);\n  float shadow = 0.0;\n#ifdef RECEIVE_SHADOWS\n  shadow = evalShadow(vpos, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\n#elif VIEWING_MODE == VIEWING_MODE_GLOBAL\n  shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n#endif\n  vec3 matColor = max(ambient, diffuse);\n  vec3 albedo_ = mixExternalColor(vcolor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n  float opacity_ = layerOpacity * mixExternalOpacity(vcolor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n  albedo_+= 0.25 * specular;\n#ifdef TRANSPARENCY_DISCARD\n  if (opacity_ < 0.001) {\n    discard;\n  }\n#endif\n  vec3 shadedColor = evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\n  gl_FragColor = vec4(shadedColor, opacity_);\n  gl_FragColor = highlightSlice(gl_FragColor, vpos);\n}","colorPass.vert":"#include <util/vsPrecision.glsl>\n#include <materials/pathMaterial/commonInputs.glsl>\n#ifdef COMPRESSED_NORMALS\nattribute vec2 normalCompressed;\n#else\nattribute vec3 normal;\n#endif\nvarying vec3 vpos;\nvarying vec3 vnormal;\n#ifdef COMPONENTCOLORS\nuniform sampler2D uComponentColorTex;\nuniform vec2 uComponentColorTexInvDim;\nattribute float componentIndex;\nvec4 readComponentColor() {\n  float normalizedIndex = (componentIndex + 0.5) * uComponentColorTexInvDim.x;\n  vec2 indexCoord = vec2(\n    mod(normalizedIndex, 1.0),\n    (floor(normalizedIndex) + 0.5) * uComponentColorTexInvDim.y\n  );\n  return texture2D(uComponentColorTex, indexCoord);\n}\n#endif\n#ifdef RECEIVE_SHADOWS\nvarying float linearDepth;\n#endif\n#ifdef SYMBOLVERTEXCOLORS\nattribute vec4 symbolColor;\n#endif\nuniform vec4 externalColor;\nvarying vec4 vcolor;\nvarying vec4 vcolorExt;\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\nvarying mediump float colorMixMode;\n#endif\n#include <materials/pathMaterial/commonFunctions.glsl>\n#include <materials/pathMaterial/localNormal.glsl>\n#include <materials/pathMaterial/colorMixMode.glsl>\nvoid main() {\n  vpos = calculateVPos();\n  vnormal = normalize((modelNormal * localNormal()).xyz);\n  gl_Position = proj * view * vec4(vpos, 1.0);\n#ifdef RECEIVE_SHADOWS\n  linearDepth = gl_Position.w;\n#endif\n  vcolorExt = externalColor;\n  vcolor = getColor();\n#ifdef SYMBOLVERTEXCOLORS\n  int symbolColorMixMode;\n  vcolorExt *= decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451;\n  colorMixMode = float(symbolColorMixMode) + 0.5;\n#endif\n#ifdef COMPONENTCOLORS\n  int symbolColorMixMode;\n  vcolorExt *= decodeSymbolColor(readComponentColor() * 255.0, symbolColorMixMode) * 0.003921568627451;\n  colorMixMode = float(symbolColorMixMode) + 0.5;\n#endif\n}","commonFunctions.glsl":"#include <util/doublePrecision.glsl>\nattribute vec4 featureValue;\nbool isCapVertex() {\n  return featureValue.w == 1.0;\n}\nuniform vec3 size;\n#if defined(VV_SIZE)\n  uniform vec3 vvSizeMinSize;\n  uniform vec3 vvSizeMaxSize;\n  uniform vec3 vvSizeOffset;\n  uniform vec3 vvSizeFactor;\n  vec3 getSize() {\n    float value = featureValue.x;\n    return size*clamp(vvSizeOffset + value * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).xzy;\n  }\n#else\n  vec3 getSize(){\n    return size;\n  }\n#endif\n#ifdef VV_OPACITY\n  #define VV_OPACITY_N 8\n  uniform float vvOpacityValues[VV_OPACITY_N];\n  uniform float vvOpacityOpacities[VV_OPACITY_N];\n  vec4 applyOpacity(vec4 color) {\n    float value = featureValue.z;\n    if (value <= vvOpacityValues[0]) {\n      return vec4( color.xyz, vvOpacityOpacities[0]);\n    }\n    for (int i = 1; i < VV_OPACITY_N; ++i) {\n      if (vvOpacityValues[i] >= value) {\n        float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);\n        return vec4( color.xyz, mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f));\n      }\n    }\n    return vec4( color.xyz, vvOpacityOpacities[VV_OPACITY_N - 1]);\n  }\n#else\n  vec4 applyOpacity(vec4 color){\n    return color;\n  }\n#endif\n#ifdef VV_COLOR\n  #define VV_COLOR_N 8\n  uniform float vvColorValues[VV_COLOR_N];\n  uniform vec4 vvColorColors[VV_COLOR_N];\n  vec4 getColor() {\n    float value = featureValue.y;\n    if (value <= vvColorValues[0]) {\n      return applyOpacity(vvColorColors[0]);\n    }\n    for (int i = 1; i < VV_COLOR_N; ++i) {\n      if (vvColorValues[i] >= value) {\n        float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);\n        return applyOpacity(mix(vvColorColors[i-1], vvColorColors[i], f));\n      }\n    }\n    return applyOpacity(vvColorColors[VV_COLOR_N - 1]);\n  }\n#else\n  vec4 getColor(){\n    return applyOpacity(vec4(1, 1, 1, 1));\n  }\n#endif\nvec3 calculateVPos() {\n  vec3 size = getSize();\n  vec3 origin = position;\n  vec3 profileRightAxis = pathGeometryInfo[0].xyz;\n  vec3 profileUpAxis = pathGeometryInfo[1].xyz;\n  vec3 offset = profileRightAxis * size.x + profileUpAxis * size.y;\n  if(!isCapVertex()) {\n    vec3 rotationRightAxis = pathGeometryInfo[2].xyz;\n    float maxDistance = length(rotationRightAxis);\n    rotationRightAxis = normalize(rotationRightAxis);\n    float rx = dot(offset, rotationRightAxis);\n    if( abs(rx) > maxDistance ) {\n      vec3 rotationUpAxis = offset - rx*rotationRightAxis;\n      offset = rotationRightAxis * maxDistance * sign(rx) + rotationUpAxis;\n    }\n  } else {\n    vec3 profilePlaneOffset = pathGeometryInfo[2].xyz*size.x;\n    offset += profilePlaneOffset;\n  }\n  vec4 localPosition = vec4(origin + offset, 1.0);\n  return (model * localPosition).xyz;\n}","commonInputs.glsl":"uniform mat4 proj;\nuniform mat4 view;\nuniform vec3 camPos;\nuniform vec3 localOrigin;\nuniform mat4 model;\nuniform mat4 modelNormal;\nattribute vec3 position;\nattribute mat3 pathGeometryInfo;","depthPass.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/encoding.glsl>\n#include <util/depth.glsl>\n#include <util/slice.glsl>\nvarying float depth;\nvarying vec3 vpos;\nvoid main() {\n  discardBySlice(vpos);\n#ifndef BIAS_SHADOWMAP\n  gl_FragColor = float2rgba(depth);\n#else\n  gl_FragColor = float2rgba(calcFragDepth(depth));\n#endif\n}","depthPass.vert":"#include <util/vsPrecision.glsl>\n#include <materials/pathMaterial/commonInputs.glsl>\nuniform vec2 nearFar;\nvarying float depth;\nvarying vec3 vpos;\n#include <materials/pathMaterial/commonFunctions.glsl>\nvoid main(void) {\n  vpos = calculateVPos();\n  vec4 eye = view * vec4(vpos, 1.0);\n  gl_Position = proj * eye;\n  depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\n}","highlightPass.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/slice.glsl>\n#include <util/highlight.glsl>\nvarying vec3 vpos;\nuniform sampler2D depthTex;\nuniform vec4 highlightViewportPixelSz;\nvoid main() {\n  discardBySlice(vpos);\n  gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n}","highlightPass.vert":"#include <util/vsPrecision.glsl>\n#include <materials/pathMaterial/commonInputs.glsl>\nvarying vec3 vpos;\n#include <materials/pathMaterial/commonFunctions.glsl>\nvoid main(void) {\n  vpos = calculateVPos();\n  gl_Position = proj * view * vec4(vpos, 1.0);\n}","localNormal.glsl":"#include <util/normalEncoding.glsl>\n# ifdef COMPRESSED_NORMALS\nvec4 localNormal() { return vec4(decodeNormal(normalCompressed), 1.0); }\n# else\nvec4 localNormal() { return vec4(normal, 1.0); }\n# endif","normalPass.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/slice.glsl>\nvarying vec3 vnormal;\nvarying vec3 vpos;\nvoid main() {\n  discardBySlice(vpos);\n  vec3 normal = normalize(vnormal);\n  if (gl_FrontFacing == false) normal = -normal;\n#ifndef ALPHA_ZERO\n  gl_FragColor = vec4(vec3(.5) + .5 * normal, 1.0);\n#else\n  gl_FragColor = vec4(vec3(.5) + .5 * normal, 0.0);\n#endif\n}","normalPass.vert":"#include <util/vsPrecision.glsl>\n#include <materials/pathMaterial/commonInputs.glsl>\nuniform mat4 viewNormal;\n#ifdef COMPRESSED_NORMALS\nattribute vec2 normalCompressed;\n#else\nattribute vec3 normal;\n#endif\nvarying vec3 vnormal;\nvarying vec3 vpos;\n#include <materials/pathMaterial/commonFunctions.glsl>\n#include <materials/pathMaterial/localNormal.glsl>\nvoid main(void) {\n  vpos = calculateVPos();\n  vnormal = normalize((viewNormal * modelNormal * localNormal()).xyz);\n  gl_Position = proj * view * vec4(vpos, 1.0);\n}","texturing.glsl":"float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\n  float deltaMaxSqr = max(dot(ddx, ddx), dot(ddy, ddy));\n  return max(0.0, 0.5 * log2(deltaMaxSqr));\n}\nvec4 textureAtlasLookup(sampler2D tex, vec2 uv, vec4 region, vec2 texSize) {\n  vec2 atlasScale = region.zw - region.xy;\n  vec2 uvAtlas = fract(uv) * atlasScale + region.xy;\n  vec2 dUVdx = dFdx(uv) * atlasScale;\n  vec2 dUVdy = dFdy(uv) * atlasScale;\n#ifdef GL_EXT_shader_texture_lod\n  return texture2DGradEXT(tex, uvAtlas, dUVdx, dUVdy);\n#else\n  vec2 dUVdxAuto = dFdx(uvAtlas);\n  vec2 dUVdyAuto = dFdy(uvAtlas);\n  float mipMapLevel = calcMipMapLevel(dUVdx * texSize, dUVdy * texSize);\n  float autoMipMapLevel = calcMipMapLevel(dUVdxAuto * texSize, dUVdyAuto * texSize);\n  return texture2D(tex, uvAtlas, mipMapLevel - autoMipMapLevel);\n#endif\n}\nvec4 textureLookup(sampler2D tex, vec2 uv) {\n#ifdef TEXTURE_ATLAS\n  return textureAtlasLookup(tex, uv, regionV, texSize);\n#else\n  return texture2D(tex, uv);\n#endif\n}"},ribbonLine:{"colorPass.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/slice.glsl>\nuniform vec4 symbolColor;\nvarying vec4 vColor;\nvarying vec2 vtc;\nvarying vec3 vpos;\n#ifdef STIPPLE\nuniform float stippleLengthDoubleInv;\n#endif\nvoid main() {\n  discardBySlice(vpos);\n#ifdef STIPPLE\n  if (fract(vtc.x * stippleLengthDoubleInv) > 0.5) {\n    discard;\n  }\n#endif\n  gl_FragColor = highlightSlice(symbolColor * vColor, vpos);\n}","highlightPass.frag":"#include <util/fsPrecision.glsl>\n#include <util/slice.glsl>\nvarying vec2 vtc;\nvarying vec3 vpos;\n#ifdef STIPPLE\nuniform float stippleLengthDoubleInv;\n#endif\nvoid main() {\n  discardBySlice(vpos);\n#ifdef STIPPLE\n  if (fract(vtc.x * stippleLengthDoubleInv) > 0.5) {\n    discard;\n  }\n#endif\n  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}","inputs.glsl":"uniform float symbolLineWidth;\n#ifdef VV_SIZE\n  attribute float sizeFeatureAttribute;\n  uniform vec3 vvSizeMinSize;\n  uniform vec3 vvSizeMaxSize;\n  uniform vec3 vvSizeOffset;\n  uniform vec3 vvSizeFactor;\n  float getSize() {\n    float value = sizeFeatureAttribute;\n    return symbolLineWidth * clamp(vvSizeOffset + value * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;\n  }\n#else\n  attribute float size;\n  float getSize(){\n    return symbolLineWidth * size;\n  }\n#endif\n#ifdef VV_OPACITY\n  attribute float opacityFeatureAttribute;\n  #define VV_OPACITY_N 8\n  uniform float vvOpacityValues[VV_OPACITY_N];\n  uniform float vvOpacityOpacities[VV_OPACITY_N];\n  float interpolateOpacity( float value ){\n    if (value <= vvOpacityValues[0]) {\n      return vvOpacityOpacities[0];\n    }\n    for (int i = 1; i < VV_OPACITY_N; ++i) {\n      if (vvOpacityValues[i] >= value) {\n        float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);\n        return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);\n      }\n    }\n    return vvOpacityOpacities[VV_OPACITY_N - 1];\n  }\n  vec4 applyOpacity( vec4 color ){\n    return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));\n  }\n#else\n  vec4 applyOpacity( vec4 color ){\n    return color;\n  }\n#endif\n#ifdef VV_COLOR\n  attribute float colorFeatureAttribute;\n  #define VV_COLOR_N 8\n  uniform float vvColorValues[VV_COLOR_N];\n  uniform vec4 vvColorColors[VV_COLOR_N];\n  vec4 interpolateColor( float value ) {\n    if (value <= vvColorValues[0]) {\n      return vvColorColors[0];\n    }\n    for (int i = 1; i < VV_COLOR_N; ++i) {\n      if (vvColorValues[i] >= value) {\n        float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);\n        return mix(vvColorColors[i-1], vvColorColors[i], f);\n      }\n    }\n    return vvColorColors[VV_COLOR_N - 1];\n  }\n  vec4 getColor(){\n    return applyOpacity(interpolateColor(colorFeatureAttribute));\n  }\n#else\n  attribute vec4 color;\n  vec4 getColor(){\n    return applyOpacity(color);\n  }\n#endif","ribbonLine.vert":"#include <util/vsPrecision.glsl>\n#include <materials/ribbonLine/inputs.glsl>\nconst float PI = 3.1415926535897932384626433832795;\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform float nearPlane;\nuniform float pixelRatio;\nattribute vec3 position;\nattribute float subdivisionFactor;\nattribute vec2 uv0;\nvarying vec2 vtc;\nvarying vec4 vColor;\nvarying vec3 vpos;\nuniform float miterLimit;\nattribute vec3 auxpos1;\nattribute vec3 auxpos2;\nuniform vec2 screenSize;\nvec4 toScreenCoords(vec3 vertex) {\n  vec4 vClipSpace = proj * view * vec4((model * vec4(vertex, 1.0)).xyz, 1.0);\n  vClipSpace.xy *= screenSize;\n  return vClipSpace/abs(vClipSpace.w);\n}\n#define PERPENDICULAR(v) vec2(v.y, -v.x);\n#define ISOUTSIDE (left.x * right.y - left.y * right.x)*uv0.y > 0.0\nfloat interp(float ncp, vec4 a, vec4 b) {\n  return (-ncp - a.z) / (b.z - a.z);\n}\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\nvoid clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {\n  float vnp = nearPlane*0.99;\n  if(pos.z > -nearPlane) {\n    if (!isStartVertex) {\n      if(prev.z < -nearPlane) {\n        pos = mix(prev, pos, interp(vnp, prev, pos));\n        next = pos;\n      } else {\n        pos = vec4(0.0, 0.0, 0.0, 1.0);\n      }\n    }\n    if(isStartVertex) {\n      if(next.z < -nearPlane) {\n        pos = mix(pos, next, interp(vnp, pos, next));\n        prev = pos;\n      } else {\n        pos = vec4(0.0, 0.0, 0.0, 1.0);\n      }\n    }\n  } else {\n    if (prev.z > -nearPlane) {\n      prev = mix(pos, prev, interp(vnp, pos, prev));\n    }\n    if (next.z > -nearPlane) {\n      next = mix(next, pos, interp(vnp, next, pos));\n    }\n  }\n  pos= proj * pos;\n  pos.xy *= screenSize;\n  pos /= pos.w;\n  next = proj * next;\n  next.xy *= screenSize;\n  next /= next.w;\n  prev = proj * prev;\n  prev.xy *= screenSize;\n  prev /= prev.w;\n}\nvoid main(void) {\n  vpos = (model * vec4(position, 1.0)).xyz;\n  if (uv0.y == 0.0) {\n    gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n  }\n  else {\n    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;\n    bool isJoin = abs(uv0.y)-3.0 < 0.0;\n    float lineWidth = getSize() * pixelRatio;\n    vec4 pos  = view * vec4((model * vec4(position.xyz, 1.0)).xyz, 1.0);\n    vec4 prev = view * vec4((model * vec4(auxpos1.xyz, 1.0)).xyz, 1.0);\n    vec4 next = view * vec4((model * vec4(auxpos2.xyz, 1.0)).xyz, 1.0);\n    clipAndTransform(pos, prev, next, isStartVertex);\n    vec2 left = (pos - prev).xy;\n    vec2 right = (next - pos).xy;\n    float leftLen = length(left);\n    left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);\n    float rightLen = length(right);\n    right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);\n    vec2 capDisplacementDir = vec2(0, 0);\n    vec2 joinDisplacementDir = vec2(0, 0);\n    float displacementLen = lineWidth;\n    if( isJoin ){\n      bool isOutside = ISOUTSIDE;\n      joinDisplacementDir = normalize(left + right);\n      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n      if (leftLen > 0.001 && rightLen > 0.001) {\n        float nDotSeg = dot(joinDisplacementDir, left);\n        displacementLen /= length(nDotSeg*left - joinDisplacementDir);\n        if (!isOutside) {\n          displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\n        }\n      }\n      if (isOutside && (displacementLen > miterLimit*lineWidth)) {\n#ifdef JOIN_ROUND\n        vec2 startDir;\n        vec2 endDir;\n        if (leftLen < 0.001) {\n          startDir = right;\n        }\n        else{\n          startDir = left;\n        }\n        startDir = normalize(startDir);\n        startDir = PERPENDICULAR(startDir);\n        if (rightLen < 0.001) {\n          endDir = left;\n        }\n        else{\n          endDir = right;\n        }\n        endDir = normalize(endDir);\n        endDir = PERPENDICULAR(endDir);\n        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));\n        joinDisplacementDir = rotate( startDir, -sign(uv0.y)*subdivisionFactor*rotationAngle );\n        displacementLen = lineWidth;\n#else\n        if (leftLen < 0.001) {\n          joinDisplacementDir = right;\n        }\n        else if (rightLen < 0.001) {\n          joinDisplacementDir = left;\n        }\n        else {\n          joinDisplacementDir = isStartVertex ? right : left;\n        }\n        joinDisplacementDir = normalize(joinDisplacementDir);\n        joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n        displacementLen = lineWidth;\n#endif\n      }\n    } else {\n      if (leftLen < 0.001) {\n        joinDisplacementDir = right;\n      }\n      else if (rightLen < 0.001) {\n        joinDisplacementDir = left;\n      }\n      else {\n        joinDisplacementDir = isStartVertex ? right : left;\n      }\n      joinDisplacementDir = normalize(joinDisplacementDir);\n      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n      displacementLen = lineWidth;\n      capDisplacementDir = isStartVertex ? -right : left;\n  #ifdef CAP_ROUND\n      float angle = subdivisionFactor*PI*0.5;\n      joinDisplacementDir *= cos(angle);\n      capDisplacementDir *= sin(angle);\n  #else\n      capDisplacementDir *= subdivisionFactor;\n  #endif\n    }\n    pos.xy += joinDisplacementDir * sign(uv0.y) * displacementLen;\n    pos.xy += capDisplacementDir * displacementLen;\n    pos.xy /= screenSize;\n    vtc = uv0;\n    vColor = getColor();\n    gl_Position = pos;\n  }\n}"},slicePlane:{"slicePlane.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\nuniform vec4 backgroundColor;\nuniform vec4 gridColor;\nuniform float ratio;\nuniform float gridWidth;\nvarying vec2 vUV;\nvoid main() {\n  const float LINE_WIDTH = 1.0;\n  vec2 uvScaled = vUV * gridWidth;\n  vec2 gridUV = (fract(uvScaled + 0.5) - 0.5) / (LINE_WIDTH * fwidth(uvScaled));\n  vec2 grid = (1.0 - step(0.5, gridUV)) * step(-0.5, gridUV);\n  grid.x *= step(0.5, uvScaled.x) * step(uvScaled.x, gridWidth - 0.5);\n  grid.y *= step(0.5, uvScaled.y) * step(uvScaled.y, gridWidth - 0.5);\n  float gridFade = max(grid.x, grid.y);\n  float gridAlpha = gridColor.a * gridFade;\n  gl_FragColor =\n    vec4(backgroundColor.rgb * backgroundColor.a, backgroundColor.a) * (1.0 - gridAlpha) +\n    vec4(gridColor.rgb, 1.0) * gridAlpha;\n}","slicePlane.vert":"#include <util/vsPrecision.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec2 vUV;\nvoid main(void) {\n  vUV = uv0;\n  gl_Position = proj * view * vec4((model * vec4(position, 1.0)).xyz, 1.0);\n}"},water:{"colorPass.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\nuniform sampler2D texWaveNormal;\nuniform sampler2D texWavePerturbation;\n#include <materials/water/waterDistortion.glsl>\n#include <util/slice.glsl>\n#ifdef RECEIVE_SHADOWS\nuniform sampler2D depthTex;\nuniform int shadowMapNum;\nuniform vec4 shadowMapDistance;\nuniform mat4 shadowMapMatrix[4];\nuniform float depthHalfPixelSz;\nvarying float linearDepth;\n#include <util/shadow.glsl>\n#endif\n#include <materials/water/waterSurface.glsl>\nuniform vec4 waterColor;\nuniform vec3 lightingMainDirection;\nuniform int shadowsEnabled;\nuniform vec3 camPos;\nuniform float timeElapsed;\nvarying vec2 uvOut;\nvarying vec3 posOut;\nvarying vec3 normalOut;\nvarying mat3 tbnMatrix;\nvoid main() {\n  discardBySlice(posOut);\n  vec3 localUp = normalOut;\n  vec2 uv = uvOut;\n  vec3 tangentNormal = getSurfaceNormal(uv, timeElapsed);\n  vec3 n = normalize(tbnMatrix * tangentNormal);\n  vec3 v = -normalize(posOut - camPos);\n  vec3 l = normalize(-lightingMainDirection);\n  float shadow = 1.0;\n#ifdef RECEIVE_SHADOWS\n  if(shadowsEnabled == 1) {\n    shadow = 1.0 - evalShadow(posOut, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\n  }\n#endif\n  vec4 final = vec4(getSeaColor(n, v, l, waterColor.rgb, localUp, shadow), waterColor.w);\n  gl_FragColor = vec4(pow(final.rgb, vec3( 1.0 / 2.2)), final.w);\n  gl_FragColor = highlightSlice(gl_FragColor, posOut);\n}","colorPass.vert":"#include <util/vsPrecision.glsl>\n#include <materials/water/normalsUtils.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform vec3 localOrigin;\nattribute vec3 position;\nattribute vec2 uv0;\n#include <materials/defaultMaterial/commonFunctions.glsl>\nvarying vec2 uvOut;\nvarying vec3 posOut;\nvarying vec3 normalOut;\nvarying mat3 tbnMatrix;\n#ifdef RECEIVE_SHADOWS\nvarying float linearDepth;\n#endif\nvoid main(void) {\n  uvOut = uv0;\n  posOut = calculateVPos();\n  normalOut = getLocalUp(posOut, localOrigin);\n  tbnMatrix = getTBNMatrix(normalOut);\n  gl_Position = proj * view * vec4(posOut.xyz, 1.0);\n  #ifdef RECEIVE_SHADOWS\n    linearDepth = gl_Position.w;\n  #endif\n}","drapedColorPass.frag":"#include <util/fsPrecision.glsl>\nuniform vec4 waterColor;\nvoid main() {\n  gl_FragColor = waterColor;\n}","drapedColorPass.vert":"#include <util/vsPrecision.glsl>\n#include <materials/water/normalsUtils.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform vec3 localOrigin;\nattribute vec3 position;\n#include <materials/defaultMaterial/commonFunctions.glsl>\nvarying vec3 posOut;\nvoid main(void) {\n  posOut = calculateVPos();\n  gl_Position = proj * view * vec4(posOut.xyz, 1.0);\n}",
"normalPass.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\nuniform sampler2D texWaveNormal;\nuniform sampler2D texWavePerturbation;\n#include <materials/water/waterDistortion.glsl>\n#include <util/slice.glsl>\nuniform float timeElapsed;\nvarying vec2 uvOut;\nvarying vec3 posOut;\nvoid main() {\n  discardBySlice(posOut);\n  vec2 uv = uvOut;\n  vec3 tangentNormal = getSurfaceNormal(uv, timeElapsed);\n  tangentNormal = normalize(tangentNormal);\n  gl_FragColor = vec4((tangentNormal + vec3(1.0)) * 0.5, 0.0);\n}","normalPass.vert":"#include <util/vsPrecision.glsl>\n#include <materials/water/normalsUtils.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform vec3 localOrigin;\nattribute vec3 position;\nattribute vec2 uv0;\n#include <materials/defaultMaterial/commonFunctions.glsl>\nvarying vec3 posOut;\nvarying vec2 uvOut;\nvoid main(void) {\n  uvOut = uv0;\n  posOut = calculateVPos();\n  gl_Position = proj * view * vec4(posOut.xyz, 1.0);\n}","normalsUtils.glsl":"vec3 getLocalUp(in vec3 pos, in vec3 origin) {\n  #if VIEWING_MODE == VIEWING_MODE_GLOBAL\n    return normalize(pos + origin);\n  #else\n    return vec3(0.0, 0.0, 1.0);\n  #endif\n}\nmat3 getTBNMatrix(in vec3 n) {\n  #if VIEWING_MODE == VIEWING_MODE_GLOBAL\n    vec3 t = normalize(cross(vec3(0.0, 0.0, 1.0), n));\n    vec3 b = normalize(cross(n, t));\n    return mat3(t, b, n);\n  #else\n    vec3 t = vec3(1.0, 0.0, 0.0);\n    vec3 b = normalize(cross(n, t));\n    return mat3(t, b, n);\n  #endif\n}","waterDistortion.glsl":"uniform vec3 octaveTextureRepeat;\nuniform vec4 waveParams;\nuniform vec2 waveDirection;\nconst vec2  FLOW_JUMP = vec2(6.0/25.0, 5.0/24.0);\nvec2 textureDenormalized2D(sampler2D _tex, vec2 _uv) {\n  return 2.0 * texture2D(_tex, _uv).rg - 1.0;\n}\nfloat sampleNoiseTexture(vec2 _uv) {\n  return texture2D(texWavePerturbation, _uv).b;\n}\nvec3 textureDenormalized3D(sampler2D _tex, vec2 _uv) {\n  return 2.0 * texture2D(_tex, _uv).rgb - 1.0;\n}\nfloat computeProgress(vec2 uv, float time) {\n  return fract(time);\n}\nfloat computeWeight(vec2 uv, float time) {\n  float progress = computeProgress(uv, time);\n  return 1.0 - abs(1.0 - 2.0 * progress);\n}\nvec3 computeUVPerturbedWeigth(sampler2D texFlow, vec2 uv, vec2 _waveDir, float time, float phaseOffset) {\n  float flowStrength = waveParams[2];\n  float flowOffset = waveParams[3];\n  vec2 flowVector = textureDenormalized2D(texFlow, uv) * flowStrength;\n  float progress = computeProgress(uv, time + phaseOffset);\n  float weight = computeWeight(uv, time + phaseOffset);\n  vec2 result = uv;\n  result -= flowVector * (progress + flowOffset);\n  result += phaseOffset;\n  result += (time - progress) * FLOW_JUMP;\n  return vec3(result, weight);\n}\nconst float TIME_NOISE_TEXTURE_REPEAT = 0.3737;\nconst float TIME_NOISE_STRENGTH = 7.77;\nvec3 getWaveLayer(sampler2D _texNormal, sampler2D _dudv, vec2 _uv, vec2 _waveDir, float time) {\n  float waveStrength = waveParams[0];\n  vec2 waveMovement = time * waveDirection;\n  float timeNoise = sampleNoiseTexture(_uv * TIME_NOISE_TEXTURE_REPEAT) * TIME_NOISE_STRENGTH;\n  vec3 uv_A = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, _waveDir, time + timeNoise, 0.0);\n  vec3 uv_B = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, _waveDir, time + timeNoise, 0.5);\n  vec3 normal_A = textureDenormalized3D(_texNormal, uv_A.xy) * uv_A.z;\n  vec3 normal_B = textureDenormalized3D(_texNormal, uv_B.xy) * uv_B.z;\n  vec3 mixNormal = normalize(normal_A + normal_B);\n  mixNormal.xy *= waveStrength;\n  mixNormal.z = sqrt(1.0 - dot(mixNormal.xy, mixNormal.xy));\n  return mixNormal;\n}\nvec3 getSurfaceNormal(vec2 _uv, float _time) {\n  float waveTextureRepeat = waveParams[1];\n  return getWaveLayer(texWaveNormal, texWavePerturbation, _uv * waveTextureRepeat, waveDirection, _time);\n}","waterSurface.glsl":"#ifdef OVERLAY\n  const vec3 skyZenitColor = vec3(0, 0.6, 0.9);\n  const vec3 skyColor = vec3(0.72, 0.92, 1.0);\n  float f0Sky = 0.02;\n  float f0maxSky = 1.0;\n  float expSky = 5.0;\n  float roughness = 0.06;\n  float f0maxSpec = 0.1;\n#else\n  uniform vec3 skyColor;\n  uniform vec3 skyZenitColor;\n  uniform float f0Sky;\n  uniform float f0maxSky;\n  uniform float expSky;\n  uniform float roughness;\n  uniform float f0maxSpec;\n#endif\nuniform vec3 lightIntensity;\n#include <util/pbrUtils.glsl>\nPBRShading shadingInfo;\nvec3 getSkyColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {\n  float exponent = pow((1.0 - cosTheta), expSky);\n  return horizon * exponent + zenit * (1.0 -  exponent);\n}\nvec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color,  in vec3 localUp, in float shadow) {\n  vec3 seaWaterColor = pow(color.rgb, vec3(2.2));\n  vec3 h = normalize(l + v);\n  shadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);\n  shadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);\n  shadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);\n  shadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  shadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);\n  shadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  float upDotV = max(dot(localUp,v), 0.0);\n  vec3 skyHorizon =  pow(skyColor, vec3(2.2));\n  vec3 skyZenit =  pow(skyZenitColor, vec3(2.2));\n  vec3 reflectedSkyColor = getSkyColor(upDotV, skyHorizon, skyZenit );\n  float upDotL = max(dot(localUp,l),0.0);\n  reflectedSkyColor *= 0.1 + upDotL * 0.9;\n  float shadowModifier = clamp(shadow, 0.8, 1.0);\n  vec3 reflSky = fresnelReflection(shadingInfo.VdotN, vec3(f0Sky), f0maxSky) * reflectedSkyColor * shadowModifier;\n  vec3 reflSea = seaWaterColor * mix(reflectedSkyColor, upDotL * lightIntensity, 2.0 / 3.0) * shadowModifier;\n  vec3 specular = vec3(0.0);\n  if(upDotV > 0.0 && upDotL > 0.0) {\n    vec3 specularSun = calculateSpecularReflectanceWater(shadingInfo, roughness, vec3(0.02), f0maxSpec);\n    vec3 incidentLight = lightIntensity * shadow;\n    specular = shadingInfo.NdotL * incidentLight * specularSun;\n  }\n  return tonemapACES(reflSky + reflSea + specular);\n}"}},misc:{"blendLayers.frag":"#include <util/fsPrecision.glsl>\nvarying vec2 uv;\nuniform sampler2D tex;\nuniform float opacity;\nvoid main() {\n  vec4 color = texture2D(tex, uv);\n  gl_FragColor = vec4(color.xyz, 1.0) * color.a * opacity;\n}","blendLayers.vert":"#include <util/vsPrecision.glsl>\nattribute vec3 position;\nattribute vec2 uv0;\nuniform float scale;\nuniform vec2 offset;\nvarying vec2 uv;\nvoid main(void) {\n  gl_Position = vec4(position, 1.0);\n  uv = uv0 * scale + offset;;\n}","texOnly.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nuniform vec4 color;\nvarying vec2 vtc;\nvoid main() {\n  vec4 texColor = texture2D(tex, vtc);\n  gl_FragColor = texColor * color;\n}","texOnly.vert":"#include <util/vsPrecision.glsl>\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec2 vtc;\nvoid main(void) {\n  gl_Position = vec4(position, 1.0);\n  vtc = uv0;\n}"},pointRenderer:{"pointRenderer.frag":"#include <util/fsPrecision.glsl>\n#include <util/encoding.glsl>\n#ifdef DEPTH_PASS\nvarying float depth;\n#else\nvarying vec3 vColor;\n#endif\nvoid main(void) {\n  vec2 vOffset = gl_PointCoord - vec2(0.5, 0.5);\n  float r2 = dot(vOffset, vOffset);\n  if (r2 > 0.25) {\n    discard;\n  }\n#ifdef DEPTH_PASS\n  gl_FragColor = float2rgba(depth);\n#else\n  gl_FragColor = vec4(vColor, 1.0);\n#endif\n}","pointRenderer.vert":"#include <util/slice.glsl>\n#include <util/vsPrecision.glsl>\nattribute vec3 aPosition;\nattribute vec3 aColor;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform vec2 uScreenMinMaxSize;\nuniform vec2 uPointScale;\nuniform vec3 uClipMin;\nuniform vec3 uClipMax;\n#ifdef DEPTH_PASS\nuniform vec2 nearFar;\nvarying float depth;\n#else\nvarying vec3 vColor;\n#endif\nvoid main(void) {\n  if (aPosition.x < uClipMin.x || aPosition.y < uClipMin.y || aPosition.z < uClipMin.z ||\n      aPosition.x > uClipMax.x || aPosition.y > uClipMax.y || aPosition.z > uClipMax.z) {\n    gl_Position = vec4(0.0,0.0,0.0,2.0);\n    gl_PointSize = 0.0;\n    return;\n  }\n  if (rejectBySlice(aPosition)) {\n    gl_Position = vec4(0.0,0.0,0.0,2.0);\n    gl_PointSize = 0.0;\n    return;\n  }\n  vec4 camera = uModelViewMatrix * vec4(aPosition, 1.0);\n  float pointSize = uPointScale.x;\n  vec4 position = uProjectionMatrix * camera;\n#ifdef DRAW_SCREEN_SIZE\n    float clampedScreenSize = pointSize;\n#else\n    float pointRadius = 0.5 * pointSize;\n    vec4 cameraOffset = camera + vec4(0.0, pointRadius, 0.0, 0.0);\n    vec4 positionOffset = uProjectionMatrix * cameraOffset;\n    float radius = abs(positionOffset.y - position.y);\n    float viewHeight = uPointScale.y;\n    float screenPointSize = (radius / position.w) * viewHeight;\n    float clampedScreenSize = clamp(screenPointSize, uScreenMinMaxSize.x, uScreenMinMaxSize.y);\n    camera.xyz -= normalize(camera.xyz) * pointRadius * clampedScreenSize / screenPointSize;\n    position = uProjectionMatrix * camera;\n#endif\n  gl_PointSize = clampedScreenSize;\n  gl_Position = position;\n#ifdef DEPTH_PASS\n  depth = (-camera.z - nearFar[0]) / (nearFar[1] - nearFar[0]);\n#else\n  vColor = aColor;\n#endif\n}"},renderer:{highlight:{"apply.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nuniform sampler2D origin;\nuniform vec4 color;\nuniform float outlineSize;\nuniform float blurSize;\nuniform vec4 opacities;\nvarying vec2 uv;\nvoid main() {\n  #if defined(GRID_OPTIMIZATION) && defined(GRID_DEBUG)\n    gl_FragColor = vec4(uv, 0.0, 1.0);\n  #else\n    vec4 blurredHighlightValue = texture2D(tex, uv);\n    float highlightIntensity = blurredHighlightValue.a;\n    if (highlightIntensity == 0.0) {\n      discard;\n    }\n    vec4 origin_color = texture2D(origin, uv);\n    float outlineIntensity;\n    float fillIntensity;\n    if (blurredHighlightValue.g > blurredHighlightValue.b) {\n      outlineIntensity = color.w * opacities[1];\n      fillIntensity = color.w * opacities[3];\n    }\n    else {\n      outlineIntensity = color.w * opacities[0];\n      fillIntensity = color.w * opacities[2];\n    }\n    float inner = 1.0 - outlineSize / 9.0;\n    float outer = 1.0 - (outlineSize + blurSize) / 9.0;\n    float outlineFactor = smoothstep(outer, inner, highlightIntensity);\n    float fillFactor = any(notEqual(origin_color, vec4(0.0, 0.0, 0.0, 0.0))) ? 1.0 : 0.0;\n    float intensity = outlineIntensity * outlineFactor * (1.0 - fillFactor) + fillIntensity * fillFactor;\n    gl_FragColor = vec4(color.xyz, intensity);\n  #endif\n}","apply.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nvarying vec2 uv;\n#ifdef GRID_OPTIMIZATION\n  attribute vec2 uv0;\n  uniform sampler2D coverageTex;\n#endif\nvoid main() {\n  #ifdef GRID_OPTIMIZATION\n    #ifdef GRID_DEBUG\n      vec4 cov = texture2D(coverageTex, uv0);\n      if (cov.r == 0.0 || cov.g == 1.0 || cov.b == 1.0) {\n        gl_Position = vec4(0.0);\n        return;\n      }\n      gl_Position = vec4(position, .0, 1.0);\n      uv = uv0;\n      return;\n    #else\n      vec4 cov = texture2D(coverageTex, uv0);\n      if (cov.r == 0.0) {\n        gl_Position = vec4(0.0);\n        return;\n      }\n    #endif\n  #endif\n  gl_Position = vec4(position, .0, 1.0);\n  uv = position.xy * .5 + vec2(.5);\n}","blur.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\n#ifdef GRID_OPTIMIZATION\n  uniform vec2 blurSize;\n  varying vec3 blurCoordinate;\n#else\n  varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n#endif\nvoid main() {\n  #ifdef GRID_OPTIMIZATION\n    vec2 uv = blurCoordinate.xy;\n    vec4 center = texture2D(tex, uv);\n    if (blurCoordinate.z == 1.0) {\n      gl_FragColor = center;\n    }\n    else {\n      vec4 sum = vec4(0.0);\n      #if GAUSSIAN_SAMPLES == 3\n        sum += center * 0.204164;\n        sum += texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n      #elif GAUSSIAN_SAMPLES == 5\n        sum += center * 0.204164;\n        sum += texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv + blurSize * 3.294215) * 0.093913;\n        sum += texture2D(tex, uv - blurSize * 3.294215) * 0.093913;\n      #elif GAUSSIAN_SAMPLES == 7\n        sum += center * 0.204164;\n        sum += texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv + blurSize * 3.294215) * 0.093913;\n        sum += texture2D(tex, uv - blurSize * 3.294215) * 0.093913;\n        sum += texture2D(tex, uv + blurSize * 5.1) * 0.03;\n        sum += texture2D(tex, uv - blurSize * 5.1) * 0.03;\n      #elif GAUSSIAN_SAMPLES == 9\n        sum += center * 0.154164;\n        sum += texture2D(tex, uv + blurSize * 1.5) * 0.204005;\n        sum += texture2D(tex, uv - blurSize * 1.5) * 0.204005;\n        sum += texture2D(tex, uv + blurSize * 3.5) * 0.123913;\n        sum += texture2D(tex, uv - blurSize * 3.5) * 0.123913;\n        sum += texture2D(tex, uv + blurSize * 5.5) * 0.123913;\n        sum += texture2D(tex, uv - blurSize * 5.5) * 0.123913;\n        sum += texture2D(tex, uv + blurSize * 7.5) * 0.05;\n        sum += texture2D(tex, uv - blurSize * 7.5) * 0.05;\n      #endif\n      gl_FragColor = sum;\n    }\n  #else\n    vec4 sum = vec4(0.0);\n    #if GAUSSIAN_SAMPLES == 3\n      sum += texture2D(tex, blurCoordinates[0]) * 0.204164;\n      sum += texture2D(tex, blurCoordinates[1]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[2]) * 0.304005;\n    #elif GAUSSIAN_SAMPLES == 5\n      sum += texture2D(tex, blurCoordinates[0]) * 0.204164;\n      sum += texture2D(tex, blurCoordinates[1]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[2]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[3]) * 0.093913;\n      sum += texture2D(tex, blurCoordinates[4]) * 0.093913;\n    #elif GAUSSIAN_SAMPLES == 7\n      sum += texture2D(tex, blurCoordinates[0]) * 0.204164;\n      sum += texture2D(tex, blurCoordinates[1]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[2]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[3]) * 0.093913;\n      sum += texture2D(tex, blurCoordinates[4]) * 0.093913;\n      sum += texture2D(tex, blurCoordinates[5]) * 0.03;\n      sum += texture2D(tex, blurCoordinates[6]) * 0.03;\n    #elif GAUSSIAN_SAMPLES == 9\n      sum += texture2D(tex, blurCoordinates[0]) * 0.154164;\n      sum += texture2D(tex, blurCoordinates[1]) * 0.204005;\n      sum += texture2D(tex, blurCoordinates[2]) * 0.204005;\n      sum += texture2D(tex, blurCoordinates[3]) * 0.123913;\n      sum += texture2D(tex, blurCoordinates[4]) * 0.123913;\n      sum += texture2D(tex, blurCoordinates[5]) * 0.09;\n      sum += texture2D(tex, blurCoordinates[6]) * 0.09;\n      sum += texture2D(tex, blurCoordinates[7]) * 0.05;\n      sum += texture2D(tex, blurCoordinates[8]) * 0.05;\n    #endif\n    gl_FragColor = sum;\n  #endif\n}","blur.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nattribute vec2 uv0;\n#ifdef GRID_OPTIMIZATION\n  uniform sampler2D coverageTex;\n  varying vec3 blurCoordinate;\n#else\n  uniform vec2 blurSize;\n  varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n#endif\nvoid main() {\n  gl_Position = vec4(position, 0.0, 1.0);\n  #ifdef GRID_OPTIMIZATION\n    vec4 cov = texture2D(coverageTex, uv0);\n    if (cov.r == 0.0) {\n      gl_Position = vec4(0.0);\n    }\n    blurCoordinate = vec3(gl_Position.xy * .5 + vec2(.5), max(cov.g, cov.b));\n  #else\n    vec2 uv = position.xy * .5 + vec2(.5);\n    #if GAUSSIAN_SAMPLES == 3\n      blurCoordinates[0] = uv;\n      blurCoordinates[1] = uv + blurSize * 1.407333;\n      blurCoordinates[2] = uv - blurSize * 1.407333;\n    #elif GAUSSIAN_SAMPLES == 5\n      blurCoordinates[0] = uv;\n      blurCoordinates[1] = uv + blurSize * 1.407333;\n      blurCoordinates[2] = uv - blurSize * 1.407333;\n      blurCoordinates[3] = uv + blurSize * 3.294215;\n      blurCoordinates[4] = uv - blurSize * 3.294215;\n    #elif GAUSSIAN_SAMPLES == 7\n      blurCoordinates[0] = uv;\n      blurCoordinates[1] = uv + blurSize * 1.407333;\n      blurCoordinates[2] = uv - blurSize * 1.407333;\n      blurCoordinates[3] = uv + blurSize * 3.294215;\n      blurCoordinates[4] = uv - blurSize * 3.294215;\n      blurCoordinates[5] = uv + blurSize * 5.1;\n      blurCoordinates[6] = uv - blurSize * 5.1;\n    #elif GAUSSIAN_SAMPLES == 9\n      blurCoordinates[0] = uv;\n      blurCoordinates[1] = uv + blurSize * 1.407333;\n      blurCoordinates[2] = uv - blurSize * 1.407333;\n      blurCoordinates[3] = uv + blurSize * 3.294215;\n      blurCoordinates[4] = uv - blurSize * 3.294215;\n      blurCoordinates[5] = uv + blurSize * 5.1;\n      blurCoordinates[6] = uv - blurSize * 5.1;\n      blurCoordinates[7] = uv + blurSize * 7.1;\n      blurCoordinates[8] = uv - blurSize * 7.1;\n    #endif\n  #endif\n}","downsample.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nuniform vec2 invFramebufferDim;\nvoid main() {\n  vec2 coord = gl_FragCoord.xy * invFramebufferDim;\n  vec4 value = texture2D(tex, coord);\n  float mx = floor(max(value.g, value.b));\n  gl_FragColor = vec4(ceil(value.r), mx, mx, 1.0);\n}","downsample.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nvoid main() {\n  gl_Position = vec4(vec2(1.0) - position * 2.0, .0, 1.0);\n}"},laserLine:{"laserLine.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/depth.glsl>\nuniform sampler2D depthMap;\nuniform vec2 nearFar;\nuniform vec4 projInfo;\nuniform vec2 zScale;\nuniform float maxPixelDistance;\nuniform vec4 focusPlane;\nuniform vec4 focusSphere;\nuniform vec4 segmentPlane;\nuniform vec3 segmentStart;\nuniform vec3 segmentEnd;\nuniform vec3 glowColor;\nuniform float glowWidth;\nuniform vec3 innerColor;\nuniform float innerWidth;\nuniform float globalAlpha;\nvarying vec2 uv;\n#define INFINITY 100000.0\nvec3 reconstructPosition(vec2 fragCoord, float depth) {\n  return vec3((fragCoord * projInfo.xy + projInfo.zw) * (zScale.x * depth + zScale.y), depth);\n}\nfloat planeDistancePixels(vec4 plane, vec3 pos) {\n  float dist = dot(plane.xyz, pos) + plane.w;\n  float width = fwidth(dist);\n  dist /= min(width, maxPixelDistance);\n  return abs(dist);\n}\nfloat sphereDistancePixels(vec4 sphere, vec3 pos) {\n  float dist = distance(sphere.xyz, pos) - sphere.w;\n  float width = fwidth(dist);\n  dist /= min(width, maxPixelDistance);\n  return abs(dist);\n}\nvec4 blendPremultiplied(vec4 source, vec4 dest) {\n  float oneMinusSourceAlpha = 1.0 - source.a;\n  return vec4(\n    source.rgb + dest.rgb * oneMinusSourceAlpha,\n    source.a + dest.a * oneMinusSourceAlpha\n  );\n}\nvec4 premultipliedColor(vec3 rgb, float alpha) {\n  return vec4(rgb * alpha, alpha);\n}\nvec4 laserLineProfile(float dist) {\n  if (dist > glowWidth) {\n    return vec4(0.0);\n  }\n  float innerAlpha = (1.0 - smoothstep(0.0, innerWidth, dist));\n  float glowAlpha = pow(max(0.0, 1.0 - dist / glowWidth), 8.0);\n  return blendPremultiplied(\n    premultipliedColor(innerColor, innerAlpha),\n    premultipliedColor(glowColor, glowAlpha)\n  );\n}\nvoid main() {\n  float depth = linearDepth(depthMap, uv, nearFar);\n  if (-depth == nearFar[0]) {\n    discard;\n  }\n  vec3 pos = reconstructPosition(gl_FragCoord.xy, depth);\n  float ddepth = fwidth(depth);\n  float depthDiscontinuityAlpha = 1.0 - smoothstep(0.0, 0.01, -ddepth / depth);\n  vec3 normal = normalize(cross(dFdx(pos), dFdy(pos)));\n  float focusPlaneDistance = planeDistancePixels(focusPlane, pos);\n  float focusSphereDistance = sphereDistancePixels(focusSphere, pos);\n  float segmentDistance = INFINITY;\n  float segmentLength = length(segmentEnd - segmentStart);\n  vec3 segmentDir = (segmentEnd - segmentStart) / segmentLength;\n  float t = dot(segmentDir, pos - segmentStart);\n  if (segmentLength > 0.0 && t >= 0.0 && t <= segmentLength) {\n    segmentDistance = planeDistancePixels(segmentPlane, pos);\n  }\n  vec4 focusPlaneColor = laserLineProfile(focusPlaneDistance);\n  vec4 focusSphereColor = laserLineProfile(focusSphereDistance);\n  vec4 segmentColor = laserLineProfile(segmentDistance);\n  float focusPlaneAlpha = 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, focusPlane.xyz)));\n  float focusSphereAlpha = 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, normalize(pos - focusSphere.xyz))));\n  float segmentAlpha = 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, segmentPlane.xyz)));\n  vec4 color = max(\n    focusPlaneColor * focusPlaneAlpha,\n    max(\n      focusSphereColor * focusSphereAlpha,\n      segmentColor * segmentAlpha\n    )\n  );\n  gl_FragColor = color * globalAlpha * depthDiscontinuityAlpha;\n}"},offscreen:{"composite.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nvarying vec2 vtc;\nvoid main() {\n  gl_FragColor = texture2D(tex, vtc);\n}","compositeOccluded.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D occludedColorMap;\nuniform float opacity;\nvarying vec2 vtc;\nvoid main() {\n  vec4 occludedColor = texture2D(occludedColorMap, vtc);\n  gl_FragColor = occludedColor * opacity;\n}","compositeTransparentToHUDVisibility.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nvarying vec2 vtc;\nvoid main() {\n  gl_FragColor = vec4(1.0 - texture2D(tex, vtc).a);\n}","offscreen.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nvarying vec2 vtc;\nvoid main(void) {\n  gl_Position = vec4(position.xy, 0.0, 1.0);\n  vtc = position.xy * 0.5 + 0.5;\n}"},ssao:{"blur.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/depth.glsl>\n#ifndef RADIUS\n#define RADIUS 4\n#endif\nuniform sampler2D normalMap;\nuniform sampler2D depthMap;\nuniform sampler2D tex;\nuniform vec2 blurSize;\nuniform float g_BlurFalloff;\nuniform float projScale;\nuniform vec2 nearFar;\nuniform vec2 zScale;\nvarying vec2 uv;\nfloat BlurFunction(vec2 uv, float r, float center_d, inout float w_total, float sharpness) {\n  float c = texture2D(tex, uv).r;\n  float d = linearDepth(depthMap, uv, nearFar);\n  float ddiff = d - center_d;\n  float w = exp(-r*r*g_BlurFalloff - ddiff*ddiff*sharpness);\n  w_total += w;\n  return w*c;\n}\nvoid main(void) {\n  float b = 0.0;\n  float w_total = 0.0;\n  float center_d = linearDepth(depthMap, uv, nearFar);\n  float sharpness = -0.05 * projScale/(center_d*zScale.x+zScale.y);\n  for (int r = -RADIUS; r <= RADIUS; ++r) {\n    float rf = float(r);\n    vec2 uvOffset = uv + rf*blurSize;\n    b += BlurFunction(uvOffset, rf, center_d, w_total, sharpness);\n  }\n  gl_FragColor = vec4(b/w_total);\n}","ssao.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/depth.glsl>\n#ifndef SAMPLES\n#define SAMPLES 4\n#endif\nuniform mat4 projMatrixInv;\nuniform sampler2D normalMap;\nuniform sampler2D depthMap;\nuniform float intensity;\nuniform float projScale;\nuniform float radius;\nuniform vec2 nearFar;\nuniform vec4 projInfo;\nuniform vec2 screenDimensions;\nuniform vec3 pSphere[SAMPLES];\nuniform vec2 rnmScale;\nuniform sampler2D rnm;\nuniform vec2 zScale;\nvarying vec2  uv;\nvarying vec4  camPos;\nfloat fallOffFunction(float vv, float vn, float bias) {\n  float radius2 = radius * radius;\n  float f = max(radius2 - vv, 0.0); return f * f * f * max(vn-bias, 0.0);\n}\nfloat aoValueFromPositionsAndNormal(vec3 C, vec3 n_C, vec3 Q) {\n  vec3 v = Q - C;\n  float vv = dot(v, v);\n  float vn = dot(normalize(v), n_C);\n  return fallOffFunction(vv, vn, 0.1);\n}\nvec3 reconstructCSPosition(vec2 S, float z) {\n  return vec3(( (S.xy) * projInfo.xy + projInfo.zw)*(z*zScale.x+zScale.y), z);\n}\nvoid main(void) {\n  vec3 fres = normalize((texture2D(rnm, uv * rnmScale).xyz * 2.0) - vec3(1.0));\n  float currentPixelDepth = linearDepth(depthMap, uv, nearFar);\n  if (-currentPixelDepth>nearFar.y || -currentPixelDepth<nearFar.x) {\n    gl_FragColor = vec4(0.0);\n    return;\n  }\n  vec3 currentPixelPos = reconstructCSPosition(gl_FragCoord.xy,currentPixelDepth);\n  vec4 norm4 = texture2D(normalMap, uv);\n  vec3 norm = vec3(-1.0) + 2.0 * norm4.xyz;\n  bool isTerrain = norm4.w<0.5;\n  float sum = .0;\n  vec4 occluderFragment;\n  vec3 ray;\n  vec3 tapPixelPos;\n  float ps = projScale/(2.0*currentPixelPos.z*zScale.x+zScale.y);\n  for(int i = 0; i < SAMPLES; ++i) {\n    vec2 unitOffset = reflect(pSphere[i], fres).xy;\n    vec2 offset = vec2(-unitOffset*radius*ps);\n    if ( abs(offset.x)<2.0 || abs(offset.y)<2.0) continue;\n    vec2 tc = vec2(gl_FragCoord.xy + offset);\n    if (tc.x < 0.0 || tc.y < 0.0 || tc.x > screenDimensions.x || tc.y > screenDimensions.y) continue;\n    vec2 tcTap = tc/screenDimensions;\n    float occluderFragmentDepth = linearDepth(depthMap, tcTap, nearFar);\n    if (isTerrain) {\n      bool isTerrainTap = texture2D(normalMap, tcTap).w<0.5;\n      if (isTerrainTap) {\n        continue;\n      }\n    }\n    tapPixelPos = reconstructCSPosition(tc, occluderFragmentDepth);\n    sum+= aoValueFromPositionsAndNormal(currentPixelPos, norm, tapPixelPos);\n  }\n  float A = max(1.0-sum*intensity/float(SAMPLES),0.0);\n  A = (pow(A, 0.2) + 1.2 * A*A*A*A) / 2.2;\n  gl_FragColor = vec4(A);\n}"}},terrainRenderer:{"colorPass.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/sceneLighting.glsl>\n#include <util/screenSizePerspective.glsl>\n#include <util/shadow.glsl>\n#include <util/slice.glsl>\n#include <terrainRenderer/overlay.glsl>\nuniform vec3 camPos;\nuniform vec3 lightDirection;\nuniform vec3 viewDirection;\nuniform sampler2D depthTex;\nuniform int shadowMapNum;\nuniform vec4 shadowMapDistance;\nuniform mat4 shadowMapMatrix[4];\nuniform float depthHalfPixelSz;\nuniform sampler2D ssaoTex;\nuniform vec4 viewportPixelSz;\nuniform sampler2D tex;\nuniform float opacity;\n#if defined(WIREFRAME_TEXTURE) || defined(TILE_BORDERS)\nstruct WireframeSettings {\n  float width;\n  float falloff;\n  float subdivision;\n  vec4 color;\n  float wireOpacity;\n  float surfaceOpacity;\n};\nuniform WireframeSettings wireframe;\n#endif\nvarying vec3 vnormal;\nvarying vec3 vpos;\nvarying vec2 vtc;\n#if defined(WIREFRAME_TEXTURE) || defined(TILE_BORDERS)\nvarying vec2 vuv;\n#endif\n#ifdef ATMOSPHERE\nvarying vec3 wnormal;\nvarying vec3 wlight;\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\nuniform vec4 screenSizePerspective;\nvarying float screenSizeDistanceToCamera;\nvarying float screenSizeCosAngle;\n#endif\nconst vec3 ambient = vec3(0.2,0.2,0.2);\nconst vec3 diffuse = vec3(0.8,0.8,0.8);\nconst float diffuseHardness = 2.5;\nconst float sliceOpacity = 0.2;\n#ifdef OVERLAY\nuniform sampler2D ovInnerColorTex;\nuniform sampler2D ovOuterColorTex;\nuniform sampler2D ovInnerWaterTex;\nuniform sampler2D ovOuterWaterTex;\nuniform float overlayOpacity;\nvarying vec4 vtcOverlay;\nvarying vec3 tbnTangent;\nvarying vec3 tbnBiTangent;\n#endif\n#ifdef RECEIVE_SHADOWS\nvarying float linearDepth;\n#endif\nfloat lum(vec3 c) {\n  float max = max(max(c.r, c.g), c.b);\n  float min = min(min(c.r, c.g), c.b);\n  return (min + max) * 0.5;\n}\n#ifdef ATMOSPHERE\nvec3 atmosphere(vec3 lightPos, vec3 normal, vec3 view) {\n  vec3 surfaceColor   = vec3(0.0);\n  vec3 fuzzySpecColor = vec3(1.0);\n  vec3 subColor       = vec3(0.0);\n  float rollOff       = 1.0;\n  vec3 Ln = normalize(lightPos);\n  vec3 Nn = normalize(normal);\n  vec3 Hn = normalize(view + Ln);\n  float ldn = dot(Ln, Nn);\n  float diffComp = max(0.0, ldn);\n  float vdn = clamp(1.0 - dot(view, Nn), 0.0, 1.0);\n  float ndv = dot(view, Ln);\n  vec3 diffContrib = surfaceColor * diffComp;\n  float subLamb = max(0.0, smoothstep(-rollOff, 1.0, ldn) - smoothstep(0.0, 1.0, ldn));\n  vec3 subContrib = subLamb * subColor;\n  vec3 vecColor = vec3(vdn);\n  vec3 diffuseContrib = (subContrib + diffContrib);\n  vec3 specularContrib = (vecColor * fuzzySpecColor);\n  return (diffContrib + specularContrib) * rollOff;\n}\n#endif\nconst float GAMMA_EXP = 0.4545454545;\nvoid main() {\n  vec3 a = ambient;\n  float shadow = 0.0;\n#ifdef RECEIVE_SHADOWS\n  shadow = evalShadow(vpos, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\n#endif\n  float vndl = dot(normalize(vnormal), lightDirection);\n  float k = smoothstep(0.0, 1.0, clamp(vndl*diffuseHardness, 0.0, 1.0));\n  vec3 d = (1.0 - shadow/1.8) * diffuse * k;\n  float ssao = viewportPixelSz.w < .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n  vec4 tileColor = texture2D(tex, vtc) * opacity;\n#ifdef OVERLAY\n  vec4 overlayColor  = overlayOpacity * getOverlayColor(ovInnerColorTex, ovOuterColorTex, vtcOverlay);\n  tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;\n#endif\n  if (rejectBySlice(vpos)) {\n    tileColor *= sliceOpacity;\n  }\n  vec3 atm = vec3(0.0);\n#ifdef ATMOSPHERE\n  float ndotl = max(0.0, min(1.0, vndl));\n  atm = atmosphere(wlight, wnormal, -viewDirection);\n  atm *= max(0.0, min(1.0, (1.0-lum(tileColor.rgb)*1.5)));\n  atm *= max(0.0, min(1.0, ndotl*2.0));\n  atm *= tileColor.a;\n#endif\n  vec3 albedo = atm + tileColor.rgb;\n  vec3 normal = normalize(vnormal);\n  float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n  vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n  gl_FragColor = vec4(evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);\n#ifdef OVERLAY\n  vec4 overlayWaterMask = getOverlayColor(ovInnerWaterTex, ovOuterWaterTex, vtcOverlay);\n  float waterNormalLength = length(overlayWaterMask);\n  if (waterNormalLength > 0.95) {\n    mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);\n    vec4 waterColor = overlayOpacity * getOverlayWaterColor(tileColor, overlayWaterMask, overlayColor, vpos, shadow, vnormal, camPos, tbnMatrix);\n    vec4 groundColor = vec4(pow(gl_FragColor.rgb, vec3(2.2)), gl_FragColor.w);\n    waterColor = mix(groundColor, waterColor, waterColor.a);\n    gl_FragColor = vec4(pow(waterColor.rgb, vec3( GAMMA_EXP )), waterColor.a);\n  }\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float perspectiveScale = screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);\n  if (perspectiveScale <= 0.25) {\n    gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n  }\n  else if (perspectiveScale <= 0.5) {\n    gl_FragColor = mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n  }\n  else if (perspectiveScale >= 0.99) {\n    gl_FragColor = mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n  }\n  else {\n    gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n  }\n#endif\n#if defined(WIREFRAME_TEXTURE) || defined(TILE_BORDERS)\n  vec2 vuvScaled = vuv * wireframe.subdivision;\n  vec2 vuvMod = fract(vuvScaled);\n  vec2 dVuv = fwidth(vuvScaled);\n  dVuv = max(vec2(0.00001), dVuv);\n  vec2 edgeFactors = smoothstep((wireframe.width - wireframe.falloff) * dVuv,\n                                wireframe.width * dVuv, min(vuvMod, 1.0 - vuvMod));\n  float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);\n#ifdef WIREFRAME_TEXTURE\n  vec3 wireframeColor = mix(gl_FragColor.rgb, wireframe.color.rgb, edgeFactor * wireframe.color.a);\n  float wireframeAlpha = mix(wireframe.surfaceOpacity, wireframe.wireOpacity, edgeFactor);\n  gl_FragColor = vec4(wireframeColor * wireframeAlpha, wireframeAlpha * gl_FragColor.a);\n#endif\n#ifdef TILE_BORDERS\n  dVuv = fwidth(vuv);\n  edgeFactors = smoothstep((wireframe.width - wireframe.falloff) * dVuv,\n                            wireframe.width * dVuv, min(vuv, 1.0 - vuv));\n  edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);\n  gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);\n#endif\n#endif\n  gl_FragColor = highlightSlice(gl_FragColor, vpos);\n}",
"colorPass.vert":"#include <util/vsPrecision.glsl>\n#include <terrainRenderer/skirts.glsl>\n#include <materials/water/normalsUtils.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform vec3 origin;\nuniform vec4 texOffsetAndScale;\nuniform mat4 viewNormal;\nuniform float skirtScale;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec3 vnormal;\nvarying vec3 vpos;\nvarying vec2 vtc;\n#ifdef RECEIVE_SHADOWS\nvarying float linearDepth;\n#endif\n#if defined(WIREFRAME_TEXTURE) || defined(TILE_BORDERS)\nvarying vec2 vuv;\n#endif\n#ifdef ATMOSPHERE\nuniform vec3 lightDirection;\nvarying vec3 wnormal;\nvarying vec3 wlight;\n#endif\n#ifdef OVERLAY\nuniform vec4 overlayTexOffset;\nuniform vec4 overlayTexScale;\nvarying vec4 vtcOverlay;\nvarying vec3 tbnTangent;\nvarying vec3 tbnBiTangent;\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\nuniform vec4 screenSizePerspective;\nvarying float screenSizeDistanceToCamera;\nvarying float screenSizeCosAngle;\n#endif\nvoid main(void) {\n  vpos = position;\n  vnormal = getLocalUp(vpos, origin);\n  vec2 uv = uv0;\n  vpos = applySkirts(uv, vpos, vnormal, skirtScale);\n#ifdef ATMOSPHERE\n  wnormal = (viewNormal * vec4(normalize(vpos+origin), 1.0)).xyz;\n  wlight = (view  * vec4(lightDirection, 1.0)).xyz;\n#endif\n#if defined(WIREFRAME_TEXTURE) || defined(TILE_BORDERS)\n  vuv = uv;\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  vec3 viewPos = (view * vec4(vpos, 1.0)).xyz;\n  screenSizeDistanceToCamera = length(viewPos);\n  vec3 viewSpaceNormal = (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n  screenSizeCosAngle = abs(viewSpaceNormal.z);\n#endif\n  gl_Position = proj * view * vec4(vpos, 1.0);\n#ifdef RECEIVE_SHADOWS\n  linearDepth = gl_Position.w;\n#endif\n  vtc = uv * texOffsetAndScale.zw + texOffsetAndScale.xy;\n#ifdef OVERLAY\n  vtcOverlay = vec4(uv, uv) * overlayTexScale + overlayTexOffset;\n  #if VIEWING_MODE == VIEWING_MODE_GLOBAL\n    tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), vnormal));\n    tbnBiTangent = normalize(cross(vnormal, tbnTangent));\n  #else\n    tbnTangent = vec3(1.0, 0.0, 0.0);\n    tbnBiTangent = normalize(cross(vnormal, tbnTangent));\n  #endif\n#endif\n}","depthPass.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/encoding.glsl>\n#include <util/depth.glsl>\nvarying float depth;\nvarying vec3 vpos;\nvoid main() {\n#ifndef BIAS_SHADOWMAP\n  gl_FragColor = float2rgba(depth);\n#else\n  gl_FragColor = float2rgba(calcFragDepth(depth));\n#endif\n}","depthPass.vert":"#include <util/vsPrecision.glsl>\n#include <terrainRenderer/skirts.glsl>\nuniform vec3 origin;\nuniform mat4 proj;\nuniform mat4 view;\nuniform vec2 nearFar;\nuniform float skirtScale;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying float depth;\nvarying vec3 vpos;\nvoid main(void) {\n#if VIEWING_MODE == VIEWING_MODE_GLOBAL\n  vec3 normal = normalize(position + origin);\n#else\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n#endif\n  vec2 uv = uv0;\n  vpos = applySkirts(uv, position, normal.xyz, skirtScale);\n  vec4 eye = view * vec4(vpos, 1.0);\n  gl_Position = proj * eye;\n  depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\n}","highlightPass.frag":"#include <util/fsPrecision.glsl>\n#include <util/highlight.glsl>\n#include <terrainRenderer/overlay.glsl>\nuniform sampler2D ovInnerColorTex;\nuniform sampler2D ovOuterColorTex;\nuniform float overlayOpacity;\nuniform sampler2D depthTex;\nuniform vec4 highlightViewportPixelSz;\nvarying vec4 vtcOverlay;\nvoid main() {\n  vec4 overlayColor = getOverlayColor(ovInnerColorTex, ovOuterColorTex, vtcOverlay) * overlayOpacity;\n  if (overlayColor.a == 0.0) {\n    gl_FragColor = vec4(0.0);\n    return;\n  }\n  gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n}","highlightPass.vert":"#include <util/vsPrecision.glsl>\n#include <terrainRenderer/skirts.glsl>\nuniform vec3 origin;\nuniform mat4 proj;\nuniform mat4 view;\nuniform vec4 overlayTexScale;\nuniform vec4 overlayTexOffset;\nuniform float skirtScale;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec3 vpos;\nvarying vec4 vtcOverlay;\nvoid main() {\n  #if VIEWING_MODE == VIEWING_MODE_GLOBAL\n    vec3 vnormal = normalize(position + origin);\n  #else\n    vec3 vnormal = vec3(0.0, 0.0, 1.0);\n  #endif\n  vec2 uv = uv0;\n  vpos = applySkirts(uv, position, vnormal, skirtScale);\n  vtcOverlay = vec4(uv, uv) * overlayTexScale + overlayTexOffset;\n  gl_Position = proj * view * vec4(vpos, 1.0);\n}","normalPass.frag":"#include <util/fsPrecision.glsl>\nvarying vec3 vnormal;\nvarying vec3 vpos;\nvoid main() {\n  vec3 normal = normalize(vnormal);\n  if (gl_FrontFacing == false) normal = -normal;\n#ifndef ALPHA_ZERO\n  gl_FragColor = vec4(vec3(.5) + .5 * normal, 1.0);\n#else\n  gl_FragColor = vec4(vec3(.5) + .5 * normal, 0.0);\n#endif\n}","normalPass.vert":"#include <util/vsPrecision.glsl>\n#include <terrainRenderer/skirts.glsl>\nuniform vec3 origin;\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 viewNormal;\nuniform float skirtScale;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec3 vnormal;\nvarying vec3 vpos;\nvoid main(void) {\n#if VIEWING_MODE == VIEWING_MODE_GLOBAL\n  vec4 normal = vec4(normalize(position + origin), 1.0);\n#else\n  vec4 normal = vec4(0.0, 0.0, 1.0, 1.0);\n#endif\n  vec2 uv = uv0;\n  vpos = applySkirts(uv, position, normal.xyz, skirtScale);\n  gl_Position = proj * view * vec4(vpos, 1.0);\n  vnormal = normalize((viewNormal * normal).xyz);\n}","overlay.glsl":"#include <materials/water/waterSurface.glsl>\n#include <util/color.glsl>\nvec4 getOverlayColor(sampler2D ov0Tex, sampler2D ov1Tex, vec4 texCoords) {\n  vec4 color = vec4(0.0);\n  vec4 color0 = texture2D(ov0Tex, texCoords.xy);\n  vec4 color1 = texture2D(ov1Tex, texCoords.zw);\n  if ((texCoords.x > 0.0) && (texCoords.x < 1.0) && (texCoords.y > 0.0) && (texCoords.y < 1.0)) {\n    color = color0;\n  } else if ((texCoords.z > 0.0) && (texCoords.z < 1.0) && (texCoords.w > 0.0) && (texCoords.w < 1.0)) {\n    color = color1;\n  }\n  return color;\n}\n#ifdef OVERLAY\nvec4 getOverlayWaterColor( in vec4 tileColor, vec4 maskInput, vec4 colorInput,\n                     vec3 vpos, float shadow, vec3 localUp, vec3 eye, mat3 tbn) {\n  vec3 n = normalize(tbn *  (2.0 * maskInput.rgb - vec3(1.0)));\n  vec3 v = -normalize(vpos - eye);\n  vec3 l = normalize(-lightingMainDirection);\n  vec3 final = getSeaColor(n, v, l, colorInput.rgb, localUp, 1.0 - shadow);\n  return premultiplyAlpha(vec4(final, colorInput.w));\n}\n#endif","skirts.glsl":"vec3 applySkirts(inout vec2 uv, vec3 vpos, vec3 vnormal, float skirtScale) {\n  float skirtLength = 0.0;\n  if (uv.x >= 2.0) {\n    skirtLength = uv.y * skirtScale;\n    vec2 x = vec2(uv.x) - vec2(3.5, 4.5);\n    uv = clamp(vec2(1.5) - abs(x), vec2(0.0), vec2(1.0));\n  }\n  return vpos - vnormal * skirtLength;\n}"},util:{"alignPixel.glsl":"vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {\n  vec2 xy = vec2(.500123) + .5 * clipCoord.xy / clipCoord.w;\n  vec2 pixelSz = vec2(1.0) / widthHeight;\n  vec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;\n  vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;\n  return vec4(result, clipCoord.zw);\n}\nvec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {\n  vec2 xy = vec2(.5) + .5 * clipCoord.xy / clipCoord.w;\n  vec2 pixelSz = vec2(1.0) / widthHeight;\n  vec2 ij = floor((xy + .5 * pixelSz) * widthHeight) * pixelSz;\n  vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;\n  return vec4(result, clipCoord.zw);\n}","color.glsl":"vec4 premultiplyAlpha(vec4 v) {\n  return vec4(v.rgb * v.a, v.a);\n}\nvec3 rgb2hsv(vec3 c) {\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}","depth.glsl":"#include <util/encoding.glsl>\nfloat linearDepth(sampler2D depthTex, vec2 uv, vec2 nearFar) {\n  return -(rgba2float(texture2D(depthTex, uv)) * (nearFar[1] - nearFar[0]) + nearFar[0]);\n}\nfloat calcFragDepth(const in float depth) {\n  const float SLOPE_SCALE = 2.0;\n  const float BIAS = 2.0 * .000015259;\n  float m = max(abs(dFdx(depth)), abs(dFdy(depth)));\n  float result = depth + SLOPE_SCALE * m + BIAS;\n  return clamp(result, .0, .999999);\n}","doublePrecision.glsl":"vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n  vec3 t1 = hiA + hiB;\n  vec3 e = t1 - hiA;\n  vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\n  return t1 + t2;\n}","enableExtensions.glsl":"#define EXTENSIONS_ENABLED\n#extension GL_OES_standard_derivatives : enable\n#extension GL_EXT_shader_texture_lod : enable","encoding.glsl":"const float MAX_RGBA_FLOAT =\n  255.0 / 256.0 +\n  255.0 / 256.0 / 256.0 +\n  255.0 / 256.0 / 256.0 / 256.0 +\n  255.0 / 256.0 / 256.0 / 256.0 / 256.0;\nconst vec4 fixedPointFactors = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\nvec4 float2rgba(const float value) {\n  float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\n  vec4 fixedPointU8 = floor(fract(valueInValidDomain * fixedPointFactors) * 256.0);\n  const float toU8AsFloat = 1.0 / 255.0;\n  return fixedPointU8 * toU8AsFloat;\n}\nconst vec4 rgba2float_factors = vec4(\n  255.0 / (256.0),\n  255.0 / (256.0 * 256.0),\n  255.0 / (256.0 * 256.0 * 256.0),\n  255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\n  return dot(rgba, rgba2float_factors);\n}","fsPrecision.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\nprecision highp sampler2D;\n#else\nprecision mediump float;\nprecision mediump sampler2D;\n#endif","highlight.glsl":"vec4 highlightData(vec4 fragCoord, sampler2D depthTex, vec4 viewportPixelSize) {\n  float sceneDepth = texture2D(depthTex, (fragCoord.xy - viewportPixelSize.xy) * viewportPixelSize.zw).r;\n  if (fragCoord.z > sceneDepth + 5e-7) {\n    return vec4(1.0, 1.0, 0.0, 1.0);\n  }\n  else {\n    return vec4(1.0, 0.0, 1.0, 1.0);\n  }\n}","hud.glsl":"#include <util/screenSizePerspective.glsl>\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec4 auxpos1;\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 viewNormal;\nuniform mat4 model;\nuniform mat4 modelNormal;\nuniform vec4 viewport;\nuniform vec3 camPos;\nuniform float polygonOffset;\nuniform float cameraGroundRelative;\nuniform float pixelRatio;\nuniform float perDistancePixelRatio;\n#ifdef VERTICAL_OFFSET\nuniform vec4 verticalOffset;\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\nuniform vec4 screenSizePerspectiveAlignment;\n#endif\nuniform sampler2D hudVisibilityTexture;\nconst float SMALL_OFFSET_ANGLE = 0.984807753012208;\nstruct ProjectHUDAux {\n  vec3 posModel;\n  vec3 posView;\n  vec3 vnormal;\n  float distanceToCamera;\n  float absCosAngle;\n};\nfloat applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {\n  float pointGroundSign = sign(pointGroundDistance);\n  if (pointGroundSign == 0.0) {\n    pointGroundSign = cameraGroundRelative;\n  }\n  float groundRelative = cameraGroundRelative * pointGroundSign;\n  if (polygonOffset > .0) {\n    float cosAlpha = clamp(absCosAngle, 0.01, 1.0);\n    float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\n    float factor = (1.0 - tanAlpha / viewport[2]);\n    if (groundRelative > 0.0) {\n      posView *= factor;\n    }\n    else {\n      posView /= factor;\n    }\n  }\n  return groundRelative;\n}\nvoid applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {\n  float distanceToCamera = length(posView);\n  float pixelOffset = distanceToCamera * perDistancePixelRatio * 0.5;\n  vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;\n  vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n  posModel += modelOffset;\n  posView += viewOffset;\n}\nvec4 projectPositionHUD(out ProjectHUDAux aux) {\n  vec3 centerOffset = auxpos1.xyz;\n  float pointGroundDistance = auxpos1.w;\n  aux.posModel = (model * vec4(position, 1.0)).xyz;\n  aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;\n  aux.vnormal = (modelNormal * vec4(normal, 1.0)).xyz;\n  applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);\n  aux.distanceToCamera = length(aux.posView);\n  vec3 viewDirObjSpace = normalize(camPos - aux.posModel);\n  float cosAngle = dot(aux.vnormal, viewDirObjSpace);\n  aux.absCosAngle = abs(cosAngle);\n#ifdef SCREEN_SIZE_PERSPECTIVE\n#if defined(VERTICAL_OFFSET) || defined(CENTER_OFFSET_UNITS_SCREEN)\n  vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);\n#endif\n#endif\n#ifdef VERTICAL_OFFSET\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);\n#else\n  float verticalOffsetScreenHeight = verticalOffset.x;\n#endif\n  float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);\n  vec3 modelOffset = aux.vnormal * worldOffset;\n  aux.posModel += modelOffset;\n  vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n  aux.posView += viewOffset;\n  pointGroundDistance += worldOffset;\n#endif\n  float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);\n#ifndef CENTER_OFFSET_UNITS_SCREEN\n  aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);\n  if (centerOffset.z != 0.0) {\n    aux.posView -= normalize(aux.posView) * centerOffset.z;\n  }\n#endif\n  vec4 posProj = proj * vec4(aux.posView, 1.0);\n#ifdef CENTER_OFFSET_UNITS_SCREEN\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);\n#else\n  float centerOffsetY = centerOffset.y;\n#endif\n  posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;\n#endif\n  posProj.z -= groundRelative * polygonOffset * posProj.w;\n  return posProj;\n}\nuniform float uRenderTransparentlyOccludedHUD;\nbool testVisibilityHUD(vec4 posProj) {\n  vec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);\n  vec4 occlusionPixel = texture2D(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);\n  if (uRenderTransparentlyOccludedHUD > 0.5) {\n    return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * uRenderTransparentlyOccludedHUD < 1.0;\n  }\n  else {\n    return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;\n  }\n}","normalEncoding.glsl":"vec3 decodeNormal(vec2 f) {\n    float z = 1.0 - abs(f.x) - abs(f.y);\n    return vec3(f + sign(f) * min(z, 0.0), z);\n}","pbrUtils.glsl":"struct PBRShading\n{\n    float NdotL;\n    float NdotV;\n    float NdotH;\n    float VdotH;\n    float LdotH;\n    float VdotN;\n};\nconst float PI_W = 3.14159265;\n#ifdef OVERLAY\n  float dtrExponent = 2.0;\n#else\n  uniform float dtrExponent;\n#endif\nvec3 fresnelReflection(float VdotH, vec3 f0, float f0Max) {\n    return f0 + (f0Max - f0) * pow(1.0 - VdotH, 5.0);\n}\nfloat normalDistributionWater(float NdotH, float roughness)\n{\n  float r2 = roughness * roughness;\n  float NdotH2 = NdotH * NdotH;\n  float denom = pow((NdotH2 * (r2 - 1.0) + 1.0), dtrExponent) * PI_W;\n  return r2 / denom;\n}\nfloat geometricOcclusionKelemen(float LoH)\n{\n    return 0.25 / (LoH * LoH);\n}\nvec3 calculateSpecularReflectanceWater(in PBRShading props, float roughness, vec3 F0, float F0Max)\n{\n  vec3  F = fresnelReflection(props.VdotH, F0, F0Max);\n  float D = normalDistributionWater(props.NdotH, roughness);\n  float V = geometricOcclusionKelemen(props.LdotH);\n  return (D * V) * F;\n}\nvec3 tonemapACES(const vec3 x) {\n  return (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);\n}","quad.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nvarying vec2 uv;\nvoid main(void) {\n  gl_Position = vec4(position.x, position.y, .0, 1.0);\n  uv = position * .5 + vec2(.5);\n}","sceneLighting.glsl":"uniform vec3 lightingMainDirection;\nuniform vec3 lightingMainIntensity;\n#ifndef SH_ORDER\n  #ifdef USE_PBR\n    #define SH_ORDER 0\n  #else\n    #define SH_ORDER 2\n  #endif\n#endif\n#if SH_ORDER == 0\n  uniform vec3 lightingAmbientSH0;\n#elif SH_ORDER == 1\n  uniform vec4 lightingAmbientSH_R;\n  uniform vec4 lightingAmbientSH_G;\n  uniform vec4 lightingAmbientSH_B;\n#elif SH_ORDER == 2\n  uniform vec3 lightingAmbientSH0;\n  uniform vec4 lightingAmbientSH_R1;\n  uniform vec4 lightingAmbientSH_G1;\n  uniform vec4 lightingAmbientSH_B1;\n  uniform vec4 lightingAmbientSH_R2;\n  uniform vec4 lightingAmbientSH_G2;\n  uniform vec4 lightingAmbientSH_B2;\n#endif\nuniform float lightingFixedFactor;\nuniform float lightingGlobalFactor;\nuniform float ambientBoostFactor;\nuniform vec3 groundColor;\nconst float GAMMA = 2.1;\nconst float PI = 3.14159;\nconst float halfPI = 1.57079;\nconst float invPI = 0.318309;\nconst float skyIlluminationAngle = 1.57079;\n#ifdef USE_PBR\n  #ifdef USE_PBR_CLEAR_COATING\n    uniform float clearCoating;\n    uniform float clearCoatRoughness;\n  #endif\n#endif\nconst vec3 clearCoatingFresnel = vec3(0.04);\nstruct PBRShadingInfo\n{\n    float NdotL;\n    float NdotV;\n    float NdotH;\n    float VdotH;\n    float LdotH;\n    float NdotNG;\n    float RdotNG;\n    vec3 diffuseColor;\n    vec3 ambientSky;\n    vec3 ambientGround;\n    float ssao;\n    vec3 groundColor;\n    vec3 albedoLinear;\n    vec3 f0;\n    vec3 f90;\n    vec3 f0_ClearCoating;\n    vec3 f90_ClearCoating;\n    float roughnessClearCoating;\n    float coating;\n    float metalness;\n    float roughness;\n    float refraction;\n};\nvec3 calculateAmbientComponent(vec3 normal, float ssao)\n{\n  #if SH_ORDER == 0\n    vec3 ambientLight = 0.282095 * lightingAmbientSH0;\n  #elif SH_ORDER == 1\n    vec4 sh0 = vec4(\n      0.282095,\n      0.488603 * normal.x,\n      0.488603 * normal.z,\n      0.488603 * normal.y\n    );\n    vec3 ambientLight = vec3(\n      dot(lightingAmbientSH_R, sh0),\n      dot(lightingAmbientSH_G, sh0),\n      dot(lightingAmbientSH_B, sh0)\n    );\n  #elif SH_ORDER == 2\n    vec3 ambientLight = 0.282095 * lightingAmbientSH0;\n    vec4 sh1 = vec4(\n      0.488603 * normal.x,\n      0.488603 * normal.z,\n      0.488603 * normal.y,\n      1.092548 * normal.x * normal.y\n    );\n    vec4 sh2 = vec4(\n      1.092548 * normal.y * normal.z,\n      0.315392 * (3.0 * normal.z * normal.z - 1.0),\n      1.092548 * normal.x * normal.z,\n      0.546274 * (normal.x * normal.x - normal.y * normal.y)\n    );\n    ambientLight += vec3(\n      dot(lightingAmbientSH_R1, sh1),\n      dot(lightingAmbientSH_G1, sh1),\n      dot(lightingAmbientSH_B1, sh1)\n    );\n    ambientLight += vec3(\n      dot(lightingAmbientSH_R2, sh2),\n      dot(lightingAmbientSH_G2, sh2),\n      dot(lightingAmbientSH_B2, sh2)\n    );\n  #endif\n  ambientLight *= (1.0 - ssao);\n  return ambientLight;\n}\nvec3 evaluateSceneLighting(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight) {\n  #if defined(TREE_RENDERING)\n    float minDot = -0.5;\n    float dotRange = 1.0 - minDot;\n    float dotNormalization = 0.66;\n    float dotVal = dotNormalization * (clamp(-dot(normal, lightingMainDirection), 1.0 - dotRange, 1.0) - minDot) * (1.0 / dotRange);\n  #else\n    float dotVal = clamp(-dot(normal, lightingMainDirection), 0.0, 1.0);\n  #endif\n  dotVal = mix(dotVal, 1.0, lightingFixedFactor);\n  vec3 mainLight = (1.0 - shadow) * lightingMainIntensity * dotVal;\n  vec3 ambientLight = calculateAmbientComponent(normal, ssao);\n  vec3 albedoGammaC = pow(albedo, vec3(GAMMA));\n  vec3 totalLight = mainLight + ambientLight + additionalLight;\n  totalLight = min(totalLight, vec3(PI, PI, PI));\n  vec3 outColor = vec3((albedoGammaC / PI) * (totalLight));\n  outColor = pow(outColor, vec3(1.0/GAMMA));\n  return outColor;\n}\nvec3 sceneLightingAdditionalLightGlobal(vec3 worldPos, float ssao, out float additionalAmbientScale) {\n#if VIEWING_MODE == VIEWING_MODE_GLOBAL\n    float vndl = -dot(normalize(worldPos), lightingMainDirection);\n#else\n    float vndl = -dot(vec3(0.0, 0.0, 1.0), lightingMainDirection);\n#endif\n  additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n  return ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n}\n#ifdef USE_PBR\n  vec3 fresnelReflection(float angle, vec3 f0, vec3 f90) {\n      return f0 + (f90 - f0) * pow(1.0 - angle, 5.0);\n  }\n  vec3 calculateDiffuseReflectanceFactor(PBRShadingInfo inputs)\n  {\n    return (1.0 - inputs.metalness) * inputs.albedoLinear * invPI;\n  }\n  float normalDistribution(float NdotH, float roughness)\n  {\n    float r2 = roughness * roughness;\n    float NdotH2 = NdotH * NdotH;\n    float denom = (NdotH2 * (r2 - 1.0) + 1.0) * (NdotH2 * (r2 - 1.0) + 1.0) * PI;\n    return r2 / denom;\n  }\n  float geometricOcclusion(float NdotV, float NdotL, float roughness)\n  {\n      float a2 = roughness * roughness;\n      float GGXL = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\n      float GGXV = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\n      return 0.5 / (GGXV + GGXL);\n  }\n  float geometricOcclusionKelemen(float LoH)\n  {\n      return 0.25 / (LoH * LoH);\n  }\n  vec3 calculateSpecularReflectanceFactor(PBRShadingInfo inputs, float roughness, vec3 f0, vec3 f90)\n  {\n    vec3  F = fresnelReflection(inputs.VdotH, f0, f90);\n    float D = normalDistribution(inputs.NdotH, roughness);\n    float V = geometricOcclusion(inputs.NdotV, inputs.NdotL, roughness);\n    return (D * V) * F;\n  }\n  vec3 brdfPBR(PBRShadingInfo inputs)\n  {\n    vec3 diffuseComponent  = calculateDiffuseReflectanceFactor(inputs);\n    vec3 specularComponent   = calculateSpecularReflectanceFactor(inputs, inputs.roughness, inputs.f0, inputs.f90);\n    #ifdef USE_PBR_CLEAR_COATING\n      vec3  Fc = fresnelReflection(inputs.LdotH, inputs.f0_ClearCoating, , inputs.f90_ClearCoating) * inputs.coating;\n      float Dc = normalDistribution(inputs.NdotH, inputs.roughnessClearCoating);\n      float Vc = geometricOcclusionKelemen(inputs.LdotH);\n      vec3 specularComponentCoating =  (Dc * Vc) * Fc;\n      return (1.0 - inputs.ssao) * (diffuseComponent * (1.0-Fc) + specularComponent * (1.0-Fc) * (1.0-Fc) + specularComponentCoating);\n    #else\n      return (1.0 - inputs.ssao) * (diffuseComponent + specularComponent);\n    #endif\n  }\n  vec3 calculateGroundComponent(PBRShadingInfo inputs)\n  {\n    return inputs.groundColor * inputs.ambientSky;\n  }\n  vec2 prefilteredDFG_Analytical(PBRShadingInfo inputs) {\n      const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n      const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n      vec4 r = inputs.roughness * c0 + c1;\n      float a004 = min(r.x * r.x, exp2(-9.28 * inputs.NdotV)) * r.x + r.y;\n      return vec2(-1.04, 1.04) * a004 + r.zw;\n  }\n      vec3 evaluateIrradianceIntegral(float firstAngle, float secondAngle, PBRShadingInfo inputs)\n      {\n        float firstAngleClamped = clamp(firstAngle, 0.0, halfPI);\n        float secondAngleClamped = clamp(secondAngle, 0.0, halfPI);\n        float ground = sin(firstAngleClamped) - sin(0.0) + sin(halfPI) - sin(secondAngleClamped);\n        float sky = sin(secondAngleClamped) - sin(firstAngleClamped);\n        return ground * inputs.ambientGround + sky * inputs.ambientSky;\n      }\n      vec3 evaluateDiffuseIllumination_Analytical(PBRShadingInfo inputs)\n      {\n        float theta = acos(max(min(inputs.NdotNG, 1.0), -1.0));\n        float firstAngle = halfPI + theta - skyIlluminationAngle;\n        float secondAngle = halfPI + theta + skyIlluminationAngle;\n        vec3 LeftIntegral = evaluateIrradianceIntegral(halfPI - secondAngle, halfPI - firstAngle, inputs);\n        vec3 RightIntegral = evaluateIrradianceIntegral(firstAngle - halfPI, secondAngle - halfPI, inputs);\n        vec3 ambientDiffuseLight = (1.0 - inputs.ssao) * (LeftIntegral + RightIntegral) / 2.0;\n        return ambientDiffuseLight;\n      }\n      float integratedRadiance(float theta, float roughness)\n      {\n        float r4 = pow(roughness, 4.0);\n        float r2 = pow(roughness, 2.0);\n        float cosT2 = cos(theta) * cos(theta);\n        float denom_1 = (cosT2 * (2.0 * r4 - 4.0 * r2 + 2.0) + 2.0 * r2 - 2.0);\n        float denom_2 = (2.0 * r4 - 2.0 * r2);\n        float integral = 2.0 * r2 * (1.0 / denom_1 - 1.0 / denom_2);\n        return integral;\n      }\n      vec3 evaluateRadianceIntegral(float firstAngle, float secondAngle, PBRShadingInfo inputs, float roughness)\n      {\n        float firstAngleClamped = clamp(firstAngle, 0.0, halfPI);\n        float secondAngleClamped = clamp(secondAngle, 0.0, halfPI);\n        float ro = roughness;\n        float ground = integratedRadiance(firstAngleClamped, ro) - integratedRadiance(0.0, ro) + integratedRadiance(halfPI, ro) - integratedRadiance(secondAngleClamped, ro);\n        float sky = integratedRadiance(secondAngleClamped, ro) - integratedRadiance(firstAngleClamped, ro);\n        return ground * inputs.ambientGround + sky * inputs.ambientSky;\n      }\n      vec3 evaluateSpecularIllumination_Analytical(PBRShadingInfo inputs, float RdotNG, float roughness)\n      {\n        float theta = acos(max(min(RdotNG, 1.0), -1.0));\n        float firstPoint = - halfPI + theta + skyIlluminationAngle;\n        float secondPoint = - halfPI + theta - skyIlluminationAngle;\n        vec3 LeftIntegral = evaluateRadianceIntegral(halfPI - firstPoint, halfPI - secondPoint, inputs, roughness);\n        vec3 RightIntegral = evaluateRadianceIntegral(secondPoint - halfPI, firstPoint - halfPI, inputs, roughness);\n        vec3 enviromentSpecularLight = (1.0 - inputs.ssao) * (LeftIntegral + RightIntegral) / 2.0;\n        return enviromentSpecularLight;\n      }\n  vec3 evaluateEnviromentIllumination(PBRShadingInfo inputs) {\n      vec3 indirectDiffuse = evaluateDiffuseIllumination_Analytical(inputs);\n      vec3 indirectSpecular = evaluateSpecularIllumination_Analytical(inputs, inputs.RdotNG, inputs.roughness);\n      vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * invPI;\n      vec2 dfg = prefilteredDFG_Analytical(inputs);\n      vec3 specularColor = inputs.f0 * dfg.x + 1.0 * dfg.y;\n      vec3 specularComponent = specularColor * indirectSpecular;\n      #ifdef USE_PBR_CLEAR_COATING\n        vec3 Fc = fresnelReflection(inputs.NdotV, inputs.f0_ClearCoating) * inputs.coating;\n        diffuseComponent  *= 1.0 - Fc;\n        specularComponent *= (1.0 - Fc) * (1.0 - Fc);\n        specularComponent += evaluateSpecularIllumination_Analytical(inputs, inputs.RdotNG, inputs.roughnessClearCoating) * Fc;\n      #endif\n      return (diffuseComponent + specularComponent);\n  }\n  vec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, float _roughness, float _metalness, vec3 _emission)\n  {\n    vec3 viewDirection = - normalize(viewDir);\n    vec3 mainLightDirection = -lightingMainDirection;\n    vec3 h = normalize(viewDirection + mainLightDirection);\n    PBRShadingInfo inputs;\n    inputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\n    inputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\n    inputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);\n    inputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);\n    inputs.LdotH = clamp(dot(mainLightDirection, h), 0.0, 1.0);\n    inputs.NdotNG = clamp(dot(normal, normalize(normalGround)), -1.0, 1.0);\n    vec3 reflectedView = normalize(reflect(viewDirection, normal));\n    inputs.refraction = dot(viewDirection, normal);\n    inputs.RdotNG = clamp(dot(reflectedView, normalize(normalGround)), -1.0, 1.0);\n    inputs.albedoLinear = pow(albedo, vec3(GAMMA));\n    inputs.groundColor = pow(vec3(0.5, 0.5, 0.5), vec3(GAMMA));\n    inputs.ssao = ssao;\n    inputs.roughness = clamp(_roughness * _roughness, 0.001, 0.99);\n    inputs.metalness = _metalness;\n    inputs.f0 = vec3(0.04) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\n    inputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));\n    inputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);\n    #ifdef USE_PBR_CLEAR_COATING\n      inputs.f0_ClearCoating = clearCoatingFresnel;\n      inputs.f90_ClearCoating = vec3(clamp(dot(inputs.f0_ClearCoating, vec3(50.0 * 0.33)), 0.0, 1.0));\n      float clearCoatRoughnessLinear = mix(0.089, 0.6, clearCoatRoughness);\n      inputs.roughnessClearCoating = clearCoatRoughnessLinear * clearCoatRoughnessLinear;\n      inputs.coating = clearCoating;\n    #endif\n    inputs.ambientSky    = calculateAmbientComponent(normal, ssao) * 1.2 - 0.2;\n    inputs.ambientGround = calculateGroundComponent(inputs);\n    inputs.NdotL = mix(inputs.NdotL, 1.0, lightingFixedFactor);\n    vec3 enviromentComponent = evaluateEnviromentIllumination(inputs);\n    vec3 additionalLightComponents = inputs.albedoLinear * (additionalLight) * invPI;\n    vec3 reflectanceFactor = brdfPBR(inputs);\n    vec3 incidentLight  =  inputs.NdotL * (1.0 - shadow) * lightingMainIntensity;\n    vec3 outColorLinear =  incidentLight * reflectanceFactor + enviromentComponent + additionalLightComponents + pow(_emission, vec3(GAMMA));\n    vec3 outColor = pow(outColorLinear, vec3(1.0/GAMMA));\n    return outColor;\n  }\n#endif","screenSizePerspective.glsl":"float screenSizePerspectiveMinSize(float size, vec4 factor) {\n  float nonZeroSize = 1.0 - step(size, 0.0);\n  return (\n    factor.z * (\n      1.0 +\n      nonZeroSize *\n      2.0 * factor.w / (\n        size + (1.0 - nonZeroSize)\n      )\n    )\n  );\n}\nfloat screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {\n  return absCosAngle * absCosAngle * absCosAngle;\n}\nvec4 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec4 params) {\n  return vec4(min(params.x / (distanceToCamera - params.y), 1.0), screenSizePerspectiveViewAngleDependentFactor(absCosAngle), params.z, params.w);\n}\nfloat applyScreenSizePerspectiveScaleFactorFloat(float size, vec4 factor) {\n  return max(mix(size * factor.x, size, factor.y), screenSizePerspectiveMinSize(size, factor));\n}\nfloat screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec4 params) {\n  return applyScreenSizePerspectiveScaleFactorFloat(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n}\nvec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec4 factor) {\n  return mix(size * clamp(factor.x, screenSizePerspectiveMinSize(size.y, factor) / size.y, 1.0), size, factor.y);\n}\nvec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec4 params) {\n  return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n}",
"shadow.glsl":"#include <util/encoding.glsl>\nfloat evalShadow(const in vec3 vpos, const in float depth, const in sampler2D depthTex, const int num, const in vec4 distance, in mat4 matrix[4], const in float halfPxSz) {\n  int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\n  if (i >= num) { return .0; }\n  mat4 mat = i == 0 ? matrix[0] : i == 1 ? matrix[1] : i == 2 ? matrix[2] : matrix[3];\n  vec4 lv = mat * vec4(vpos, 1.0);\n  lv.xy /= lv.w;\n  vec3 lvpos = .5 * lv.xyz + vec3(.5);\n  if (lvpos.z >= 1.0) { return .0; }\n  if (lvpos.x < .0 || lvpos.x > 1.0 || lvpos.y < .0 || lvpos.y > 1.0) { return .0; }\n  vec2 uv = vec2(float(i - 2 * (i / 2)) *.5, float(i / 2) * .5) + .5 * lvpos.xy;\n  float texSize = .5 / halfPxSz;\n  vec2 st = fract((vec2(halfPxSz) + uv) * texSize);\n  float s00 = rgba2float(texture2D(depthTex, uv + vec2(-halfPxSz, -halfPxSz))) < lvpos.z ? 1.0 : .0;\n  float s10 = rgba2float(texture2D(depthTex, uv + vec2(halfPxSz, -halfPxSz))) < lvpos.z ? 1.0 : .0;\n  float s11 = rgba2float(texture2D(depthTex, uv + vec2(halfPxSz, halfPxSz))) < lvpos.z ? 1.0 : .0;\n  float s01 = rgba2float(texture2D(depthTex, uv + vec2(-halfPxSz, halfPxSz))) < lvpos.z ? 1.0 : .0;\n  return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n}","slice.glsl":"#ifdef SLICE\nuniform vec3 slicePlaneOrigin;\nuniform vec3 slicePlaneBasis1;\nuniform vec3 slicePlaneBasis2;\nstruct SliceFactors {\n  float front;\n  float side0;\n  float side1;\n  float side2;\n  float side3;\n};\nSliceFactors calculateSliceFactors(vec3 pos) {\n  vec3 rel = pos - slicePlaneOrigin;\n  vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);\n  float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);\n  float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);\n  float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);\n  float basis1Dot = dot(slicePlaneBasis1, rel);\n  float basis2Dot = dot(slicePlaneBasis2, rel);\n  return SliceFactors(\n    dot(slicePlaneNormal, pos) + slicePlaneW,\n    -basis1Dot - basis1Len2,\n    basis1Dot - basis1Len2,\n    -basis2Dot - basis2Len2,\n    basis2Dot - basis2Len2\n  );\n}\nbool sliceByFactors(SliceFactors factors) {\n  return factors.front < 0.0\n    && factors.side0 < 0.0\n    && factors.side1 < 0.0\n    && factors.side2 < 0.0\n    && factors.side3 < 0.0;\n}\nbool sliceByPlane(vec3 pos) {\n  return sliceByFactors(calculateSliceFactors(pos));\n}\n#ifdef EXTENSIONS_ENABLED\nvec4 applySliceHighlight(vec4 color, vec3 pos) {\n  SliceFactors factors = calculateSliceFactors(pos);\n  if (sliceByFactors(factors)) {\n    return color;\n  }\n  const float HIGHLIGHT_WIDTH = 1.0;\n  const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);\n  factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);\n  factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);\n  factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);\n  factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);\n  factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);\n  float highlightFactor = (1.0 - step(0.5, factors.front))\n    * (1.0 - step(0.5, factors.side0))\n    * (1.0 - step(0.5, factors.side1))\n    * (1.0 - step(0.5, factors.side2))\n    * (1.0 - step(0.5, factors.side3));\n  return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);\n}\n#else\n#endif\n#define rejectBySlice(_pos_) sliceByPlane(_pos_)\n#define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }\n#ifdef SLICE_HIGHLIGHT_DISABLED\n#define highlightSlice(_color_, _pos_) (_color_)\n#else\n#define highlightSlice(_color_, _pos_) applySliceHighlight(_color_, _pos_)\n#endif\n#else\n#define rejectBySlice(_pos_) false\n#define discardBySlice(_pos_) {}\n#define highlightSlice(_color_, _pos_) (_color_)\n#endif","visualVariables.glsl":"#if defined(VV_SIZE)\n  #define VV_CUSTOM_MODEL_MATRIX\n#endif\n#if defined(VV_SIZE)\n  uniform vec3 vvSizeMinSize;\n  uniform vec3 vvSizeMaxSize;\n  uniform vec3 vvSizeOffset;\n  uniform vec3 vvSizeFactor;\n#elif defined(VV_CUSTOM_MODEL_MATRIX)\n  uniform vec3 vvSizeValue;\n#endif\n#ifdef VV_CUSTOM_MODEL_MATRIX\n  uniform mat3 vvSymbolRotationMatrix;\n#endif\n#ifdef VV_CUSTOM_MODEL_MATRIX\n  uniform vec3 vvSymbolAnchor;\n#endif\n#ifdef VV_COLOR\n  #define VV_COLOR_N 8\n  uniform float vvColorValues[VV_COLOR_N];\n  uniform vec4 vvColorColors[VV_COLOR_N];\n#endif\n#if defined(VV_SIZE)\n  vec3 vvGetScale(vec4 featureAttribute) {\n    return clamp(vvSizeOffset + featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);\n  }\n#elif defined(VV_CUSTOM_MODEL_MATRIX)\n  vec3 vvGetScale(vec4 featureAttribute) {\n    return vvSizeValue;\n  }\n#endif\n#ifdef VV_CUSTOM_MODEL_MATRIX\n  vec4 vvTransformPosition(vec3 position, vec4 featureAttribute) {\n    return vec4(vvSymbolRotationMatrix * (vvGetScale(featureAttribute) * (position + vvSymbolAnchor)), 1.0);\n  }\n  vec4 vvTransformNormal(vec3 normal, vec4 featureAttribute) {\n    return vec4(vvSymbolRotationMatrix * normal / vvGetScale(featureAttribute), 1.0);\n  }\n#endif\n#ifdef VV_COLOR\n  vec4 vvGetColor(vec4 featureAttribute, float values[VV_COLOR_N], vec4 colors[VV_COLOR_N]) {\n    float value = featureAttribute.y;\n    if (value <= values[0]) {\n      return colors[0];\n    }\n    for (int i = 1; i < VV_COLOR_N; ++i) {\n      if (values[i] >= value) {\n        float f = (value - values[i-1]) / (values[i] - values[i-1]);\n        return mix(colors[i-1], colors[i], f);\n      }\n    }\n    return colors[VV_COLOR_N - 1];\n  }\n#endif","vsPrecision.glsl":"precision highp float;\nprecision highp sampler2D;"}}});